<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>后台开发 - 分类 - TechInsights - Chuxing's Blog</title><link>https://xzygis.github.io/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/</link><description>后台开发 - 分类 - TechInsights - Chuxing's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xzygis@163.com (chuxing)</managingEditor><webMaster>xzygis@163.com (chuxing)</webMaster><lastBuildDate>Sat, 12 Jun 2021 16:22:56 +0000</lastBuildDate><atom:link href="https://xzygis.github.io/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/" rel="self" type="application/rss+xml"/><item><title>浅谈Bloom Filter基本原理及使用方式</title><link>https://xzygis.github.io/posts/introduction-to-the-basic-principles-of-bloom-filter/</link><pubDate>Sat, 12 Jun 2021 16:22:56 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/introduction-to-the-basic-principles-of-bloom-filter/</guid><description><![CDATA[<p>一提到元素查找，我们会很自然的想到<code>HashMap</code>。通过将哈希函数作用于key上，我们得到了哈希值，基于哈希值我们可以去表里的相应位置获取对应的数据。除了存在哈希冲突问题之外，<code>HashMap</code>一个很大的问题就是空间效率低。引入<code>Bloom Filter</code>则可以很好的解决空间效率的问题。</p>
<h2 id="原理">原理</h2>
<p>Bloom Filter是一种空间效率很高的随机数据结构，Bloom filter 可以看做是对bit-map 的扩展，布隆过滤器被设计为一个具有N的元素的位数组A（bit array），初始时所有的位都置为0。</p>
<p>当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位阵列（Bit array）中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了。</p>
<ul>
<li>如果这些点有任何一个 0，则被检索元素一定不在；</li>
<li>如果都是 1，则被检索元素很可能在。</li>
</ul>
<h2 id="添加元素">添加元素</h2>
<p>要添加一个元素，我们需要提供k个哈希函数。每个函数都能返回一个值，这个值必须能够作为位数组的索引（可以通过对数组长度进行取模得到）。然后，我们把位数组在这个索引处的值设为1。例如，第一个哈希函数作用于元素I上，返回x。类似的，第二个第三个哈希函数返回y与z，那么：
<code>A[x]=A[y]=A[z] = 1</code></p>
<h2 id="查找元素">查找元素</h2>
<p>查找的过程与上面的过程类似，元素将会被会被不同的哈希函数处理三次，每个哈希函数都返回一个作为位数组索引值的整数，然后我们检测位数组在x、y与z处的值是否为1。如果有一处不为1，那么就说明这个元素没有被添加到这个布隆过滤器中。如果都为1，就说明这个元素在布隆过滤器里面。当然，会有一定误判的概率。</p>
<h2 id="算法优化">算法优化</h2>
<p>通过上面的解释我们可以知道，如果想设计出一个好的布隆过滤器，我们必须遵循以下准则：</p>
<ul>
<li>好的哈希函数能够尽可能的返回宽范围的哈希值。</li>
<li>位数组的大小（用m表示）非常重要：如果太小，那么所有的位很快就都会被赋值为1，这样就增加了误判的几率。</li>
<li>哈希函数的个数（用k表示）对索引值的均匀分配也很重要。</li>
</ul>
<p>计算m的公式如下：
<code>m = - nlog p / (log2)^2</code>
这里p为可接受的误判率。</p>
<p>计算k的公式如下：
<code>k = m/n log(2)</code>
这里k=哈希函数个数，m=位数组个数，n=待检测元素的个数（后面会用到这几个字母）。</p>
<h2 id="哈希算法">哈希算法</h2>
<p>哈希算法是影响布隆过滤器性能的地方。我们需要选择一个效率高但不耗时的哈希函数，在论文《更少的哈希函数，相同的性能指标：构造一个更好的布隆过滤器》中，讨论了如何选用2个哈希函数来模拟k个哈希函数。首先，我们需要计算两个哈希函数h1(x)与h2(x)。然后，我们可以用这两个哈希函数来模仿产生k个哈希函数的效果：
<code>gi(x) = h1(x) + ih2(x)</code>
这里i的取值范围是1到k的整数。</p>
<p>Google Guava类库使用这个技巧实现了一个布隆过滤器，哈希算法的主要逻辑如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">long</span> <span class="n">hash64</span> <span class="o">=</span> <span class="o">...;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">hash1</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">hash64</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">hash2</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="n">hash64</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">32</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">numHashFunctions</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">combinedHash</span> <span class="o">=</span> <span class="n">hash1</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">hash2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Flip all the bits if it&#39;s negative (guaranteed positive number)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="o">(</span><span class="n">combinedHash</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">combinedHash</span> <span class="o">=</span> <span class="o">~</span><span class="n">combinedHash</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Guava中的Bloom Filter使用示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">expectedInsertions</span> <span class="o">=</span> <span class="o">...;</span> <span class="c1">//待检测元素的个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">double</span> <span class="n">fpp</span> <span class="o">=</span> <span class="mf">0.03</span><span class="o">;</span> <span class="c1">//误判率(desired false positive probability)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BloomFilter</span><span class="o">&lt;</span><span class="n">CharSequence</span><span class="o">&gt;</span> <span class="n">bloomFilter</span> <span class="o">=</span> <span class="n">BloomFilter</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">Funnels</span><span class="o">.</span><span class="na">stringFunnel</span><span class="o">(</span><span class="n">Charset</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;UTF-8&#34;</span><span class="o">)),</span> <span class="n">expectedInsertions</span><span class="o">,</span><span class="n">fpp</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="优点">优点</h2>
<p>它的优点是空间效率和查询时间都远远超过一般的算法，布隆过滤器存储空间和插入/查询时间都是常数O(k)。另外, 散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p>
<h2 id="缺点">缺点</h2>
<p>布隆过滤器的缺点和优点一样明显，误算率是其中之一。</p>
<p>另外，一般情况下不能从布隆过滤器中删除元素。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1，这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面，而这一点单凭这个过滤器是无法保证的。</p>
<p>参考来源：</p>
<ul>
<li><a href="https://www.javacodegeeks.com/2014/07/how-to-use-bloom-filter-to-build-a-large-in-memory-cache-in-java.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.javacodegeeks.com/2014/07/how-to-use-bloom-filter-to-build-a-large-in-memory-cache-in-java.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://www.cnblogs.com/haippy/archive/2012/07/13/2590351.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/haippy/archive/2012/07/13/2590351.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://segmentfault.com/a/1190000002729689"target="_blank" rel="external nofollow noopener noreferrer">https://segmentfault.com/a/1190000002729689<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
]]></description></item><item><title>Linux文件传输的三种方式</title><link>https://xzygis.github.io/posts/three-ways-to-transfer-files-in-linux/</link><pubDate>Sat, 12 Jun 2021 16:14:22 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/three-ways-to-transfer-files-in-linux/</guid><description><![CDATA[<h2 id="1-nc命令">1 nc命令</h2>
<p>执行如下命令，在目标机器(假设ip为<code>10.11.12.13</code>)上监听端口<code>8415</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">nc -l 8415 &gt; data.txt
</span></span></code></pre></td></tr></table>
</div>
</div><p>往目标机器发送数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">nc -v 10.11.12.13 8415 &lt; ~/Downloads/data.txt
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="2-simplehttpserver">2 SimpleHTTPServer</h2>
<p>在服务器(假设ip为<code>10.11.12.13</code>)上执行如下命令:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">python -m SimpleHTTPServer 8411 
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后在本地机器打开浏览器，输入<code>http://10.11.12.13:8411/</code>可以访问。</p>
<h2 id="3-scp命令">3 scp命令</h2>
<p>Linux scp命令用于Linux之间复制文件和目录。</p>
<p>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</p>
<p>在目标机器执行如下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">scp -l 700000 username@dev.test.com:~/data.txt ./ 
</span></span></code></pre></td></tr></table>
</div>
</div><p>即可把目标机器dev.test.com的文件~/data.txt拷贝到当前目录。</p>
]]></description></item></channel></rss>