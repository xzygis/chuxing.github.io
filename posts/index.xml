<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>所有文章 - 楚兴 - Chuxing's Blog</title><link>https://xzygis.github.io/posts/</link><description>Chuxing's Tech Blog</description><generator>Hugo 0.133.0 &amp; FixIt v0.3.10-08d4c12c</generator><language>zh-CN</language><lastBuildDate>Wed, 30 Aug 2023 22:42:11 +0800</lastBuildDate><atom:link href="https://xzygis.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>《关键跨越：从业务高手到优秀主管》：最大化团队产出</title><link>https://xzygis.github.io/posts/key-leap-from-business-master-to-excellent-executive/</link><pubDate>Wed, 30 Aug 2023 22:24:24 +0800</pubDate><guid>https://xzygis.github.io/posts/key-leap-from-business-master-to-excellent-executive/</guid><category domain="https://xzygis.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/">个人成长</category><description>作者：北森人才管理研究院 阅读时长：6小时21分钟 评分：5星+ 失控最鲜明的特征之一是管理者工作的时间越来越长，但结果越来越糟。很多新手管理者看到下属无法完成任务，或者担心出错，对下属不放心，出于对效率和成果的考量，会索性选择自己上手干。管理者事必躬亲，在执行性工作上投入大量时间，会渐渐发现自己每天都有</description></item><item><title>ES数据建模之关联关系处理</title><link>https://xzygis.github.io/posts/es-modeling-your-data/</link><pubDate>Wed, 12 Apr 2023 21:08:02 +0800</pubDate><guid>https://xzygis.github.io/posts/es-modeling-your-data/</guid><category domain="https://xzygis.github.io/categories/storage/">Storage</category><description>现实世界有很多重要的关联关系：博客帖子有一些评论，银行账户有多次交易记录，客户有多个银行账户，订单有多个订单明细，文件目录有多个文件和子目录。 内部对象数组 考虑包含内部对象的数组是如何被索引的。 假设我们有个 followers 数组： 1 2 3 4 5 6 7 { &amp;#34;followers&amp;#34;: [ { &amp;#34;age&amp;#34;: 35, &amp;#34;name&amp;#34;: &amp;#34;Mary White&amp;#34;}, { &amp;#34;age&amp;#34;: 26, &amp;#34;name&amp;#34;: &amp;#34;Alex Jones&amp;#34;}, { &amp;#34;age&amp;#34;: 19, &amp;#34;name&amp;#34;: &amp;#34;Lisa Smith&amp;#34;} ] } 这个文档会像我们之前描述的那</description></item><item><title>Redis 复制</title><link>https://xzygis.github.io/posts/introduction-to-redis-replication/</link><pubDate>Wed, 01 Feb 2023 22:13:25 +0800</pubDate><guid>https://xzygis.github.io/posts/introduction-to-redis-replication/</guid><category domain="https://xzygis.github.io/categories/cache/">Cache</category><description>在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）。 进行复制中的主从服务器双方的数据库将保存相同的数据，概念上</description></item><item><title>Redis 事件</title><link>https://xzygis.github.io/posts/introduction-to-redis-event/</link><pubDate>Wed, 01 Feb 2023 21:34:52 +0800</pubDate><guid>https://xzygis.github.io/posts/introduction-to-redis-event/</guid><category domain="https://xzygis.github.io/categories/cache/">Cache</category><description>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件： 文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件</description></item><item><title>Redis 服务器</title><link>https://xzygis.github.io/posts/introduction-to-redis-server/</link><pubDate>Wed, 21 Dec 2022 19:42:15 +0800</pubDate><guid>https://xzygis.github.io/posts/introduction-to-redis-server/</guid><category domain="https://xzygis.github.io/categories/cache/">Cache</category><description>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。 命令请求的执行过程 发送命令请求 Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格</description></item><item><title>Redis 客户端</title><link>https://xzygis.github.io/posts/introduction-to-redis-client/</link><pubDate>Mon, 12 Dec 2022 23:07:04 +0800</pubDate><guid>https://xzygis.github.io/posts/introduction-to-redis-client/</guid><category domain="https://xzygis.github.io/categories/cache/">Cache</category><description>Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。 通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户</description></item><item><title>Redis AOF持久化</title><link>https://xzygis.github.io/posts/introduction-to-redis-aof-persistence/</link><pubDate>Sat, 10 Dec 2022 14:21:33 +0800</pubDate><guid>https://xzygis.github.io/posts/introduction-to-redis-aof-persistence/</guid><category domain="https://xzygis.github.io/categories/cache/">Cache</category><description>除了RDB持久化功能1之外，Redis还提供了AOF（Append Only File）持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。 服务器在启动时，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的</description></item><item><title>Redis RDB持久化</title><link>https://xzygis.github.io/posts/introduction-to-redis-rdb-persistence/</link><pubDate>Fri, 09 Dec 2022 23:22:14 +0800</pubDate><guid>https://xzygis.github.io/posts/introduction-to-redis-rdb-persistence/</guid><category domain="https://xzygis.github.io/categories/cache/">Cache</category><description>Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对，为了方便起见，我们将服务器中的非空数据库以及它们的键值对统称为数据库状态。 因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到</description></item><item><title>Redis 服务器数据库实现</title><link>https://xzygis.github.io/posts/redis-server-database-implementation-introduction/</link><pubDate>Thu, 08 Dec 2022 23:39:55 +0800</pubDate><guid>https://xzygis.github.io/posts/redis-server-database-implementation-introduction/</guid><category domain="https://xzygis.github.io/categories/cache/">Cache</category><description>服务器中的数据库1 Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库： 1 2 3 4 5 6 struct redisServer { // ... // 一个数组，保存着服务器中的所有数据库 redisDb *db; // ... }; 在初始化服务</description></item><item><title>Redis 对象</title><link>https://xzygis.github.io/posts/introduction-to-redis-object/</link><pubDate>Wed, 07 Dec 2022 20:10:37 +0800</pubDate><guid>https://xzygis.github.io/posts/introduction-to-redis-object/</guid><category domain="https://xzygis.github.io/categories/cache/">Cache</category><description>在 Redis底层数据结构介绍1 中我们介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序</description></item><item><title>Hugo 快速入门</title><link>https://xzygis.github.io/posts/hugo-quick-start/</link><pubDate>Sat, 03 Dec 2022 19:21:25 +0800</pubDate><guid>https://xzygis.github.io/posts/hugo-quick-start/</guid><category domain="https://xzygis.github.io/categories/%E5%8D%9A%E5%AE%A2/">博客</category><description>Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 Intall 1 go install github.com/gohugoio/hugo@latest Quick Start https://gohugo.io/getting-started/quick-start/ 运行以下命令创建一个使用Ananke主题的网站： 1 2 3 4 5 6 hugo new site quickstart cd quickstart git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke echo &amp;#34;theme = &amp;#39;ananke&amp;#39;&amp;#34; &amp;gt;&amp;gt; config.toml hugo server Add Content 给网站增加新的网页： 1 hugo new posts/my-first-post.md Hugo在content/posts目录创建了my-first-post</description></item><item><title>Redis 底层数据结构</title><link>https://xzygis.github.io/posts/introduction-to-the-underlying-data-structure-of-redis/</link><pubDate>Wed, 30 Nov 2022 22:03:21 +0000</pubDate><guid>https://xzygis.github.io/posts/introduction-to-the-underlying-data-structure-of-redis/</guid><category domain="https://xzygis.github.io/categories/cache/">Cache</category><description>简单动态字符串1 每个sds.h/sdshdr结构表示一个SDS值： 1 2 3 4 5 6 7 8 9 struct sdshdr { //记录buf数组中已使用字节的数量 //等于SDS所保存字符串的长度 int len; //记录buf数组中未使用字节的数量 int free; //字节数组，用于保存字符串 char buf[]; }; SDS与C字符串的区别 常数时间复杂度获取字符串长度 杜绝缓冲区溢出</description></item><item><title>Tair:分布式键/值存储系统</title><link>https://xzygis.github.io/posts/tair-a-distributed-key-value-storage-system-developed-by-alibaba-group/</link><pubDate>Sun, 27 Nov 2022 23:11:28 +0000</pubDate><guid>https://xzygis.github.io/posts/tair-a-distributed-key-value-storage-system-developed-by-alibaba-group/</guid><category domain="https://xzygis.github.io/categories/cache/">Cache</category><description>产品概览 Tair 是快速访问内存 (MDB)/持久性 (LDB) 存储服务。 Tair采用高性能、高可用的分布式集群架构，可以满足企业对读写性能和可扩展容量的高要求。 系统架构 Tair 集群具有三个必要的模块：ConfigServer、DataServer 和客户端。 通常，一个 Tair 集群包括两个 ConfigServer 和多个 DataServer。 两个 ConfigServer 充当主服</description></item><item><title>程序员做需求时容易忽视的若干问题</title><link>https://xzygis.github.io/posts/some-problems-that-programmers-tend-to-ignore-when-making-requirements/</link><pubDate>Sun, 20 Nov 2022 23:33:08 +0000</pubDate><guid>https://xzygis.github.io/posts/some-problems-that-programmers-tend-to-ignore-when-making-requirements/</guid><category domain="https://xzygis.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/">个人成长</category><description>程序员大部分时间都在承接一个个的需求，在做需求的过程中，有一些问题是我们容易忽视的，究其原因，主要是在做需求的过程中缺少思考，或者思考不够全面。而思考的缺失，正是导致部分人所说的“做业务需求没有成长”的主要原因之一。今天主要从研发流程中重要的几个阶段出发，跟大家谈谈做需求的过程中有哪些是我们容易忽视</description></item><item><title>给新人程序员的职场建议</title><link>https://xzygis.github.io/posts/career-advice-for-beginning-programmers/</link><pubDate>Sun, 20 Nov 2022 22:01:20 +0000</pubDate><guid>https://xzygis.github.io/posts/career-advice-for-beginning-programmers/</guid><category domain="https://xzygis.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/">个人成长</category><description>我是一位在大厂打拼多年的程序员，今天想结合自己的工作经历给新人程序员们提出若干建议，希望能够在一定程度上帮助大家在职场脱颖而出。 积极主动 第一个建议是要积极主动，有owner意识，勇于承担工作职责，并在工作中做出成绩。 首先，领取任务或接受任务应该积极主动。在工作中可以主动向领导提出来自己对什么方向的项</description></item><item><title>浅谈Bloom Filter基本原理及使用方式</title><link>https://xzygis.github.io/posts/introduction-to-the-basic-principles-of-bloom-filter/</link><pubDate>Sat, 12 Jun 2021 16:22:56 +0000</pubDate><guid>https://xzygis.github.io/posts/introduction-to-the-basic-principles-of-bloom-filter/</guid><category domain="https://xzygis.github.io/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/">后台开发</category><description>一提到元素查找，我们会很自然的想到HashMap。通过将哈希函数作用于key上，我们得到了哈希值，基于哈希值我们可以去表里的相应位置获取对应的数据。除了存在哈希冲突问题之外，HashMap一个很大的问题就是空间效率低。引入Bloom Filter则可以很好的解决空间效率的问题。 原理 Bloom Filter是一种</description></item><item><title>Linux文件传输的三种方式</title><link>https://xzygis.github.io/posts/three-ways-to-transfer-files-in-linux/</link><pubDate>Sat, 12 Jun 2021 16:14:22 +0000</pubDate><guid>https://xzygis.github.io/posts/three-ways-to-transfer-files-in-linux/</guid><category domain="https://xzygis.github.io/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/">后台开发</category><description>1 nc命令 执行如下命令，在目标机器(假设ip为10.11.12.13)上监听端口8415 1 nc -l 8415 &amp;gt; data.txt 往目标机器发送数据 1 nc -v 10.11.12.13 8415 &amp;lt; ~/Downloads/data.txt 2 SimpleHTTPServer 在服务器(假设ip为10.11.12.13)上执行如下命令: 1 python -m SimpleHTTPServer 8411 然后在本地机器打开浏览器，输入http://10.11.12.13:8411/可以访问。 3 sc</description></item><item><title>Websocket介绍</title><link>https://xzygis.github.io/posts/introduction-of-websocket/</link><pubDate>Sat, 12 Jun 2021 15:25:21 +0000</pubDate><guid>https://xzygis.github.io/posts/introduction-of-websocket/</guid><category domain="https://xzygis.github.io/categories/http/">HTTP</category><description>什么是WebSocket？ WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。WebSocket协议在2011年由IETF标准化为RFC 6455，后由RFC 7936补充规范。 WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向</description></item><item><title>Consul入门手册</title><link>https://xzygis.github.io/posts/manual-of-consul/</link><pubDate>Thu, 30 Jan 2020 13:35:59 +0000</pubDate><guid>https://xzygis.github.io/posts/manual-of-consul/</guid><description>Consul是什么？ Consul是一个服务发现和配置工具，它是分布式和高可用的，而且极易扩展。 Consul主要提供了以下特性： 服务发现：Consul使得服务注册和服务发现（通过DNS或HTTP接口）变得非常简单。 健康检查：健康检查使得Consul可以快速向管理员报告集群状况。将它与服务发现集成，可以</description></item><item><title>JSON Web Token入门手册</title><link>https://xzygis.github.io/posts/usage-of-json-web-token/</link><pubDate>Thu, 30 Jan 2020 13:10:39 +0000</pubDate><guid>https://xzygis.github.io/posts/usage-of-json-web-token/</guid><category domain="https://xzygis.github.io/categories/http/">HTTP</category><description>跨域认证问题 互联网服务离不开用户认证。一般流程是下面这样： 用户向服务器发送用户名和密码。 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。 服务器向用户返回一个 session_id，写入用户的 Cookie。 用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服</description></item><item><title>Docker之容器使用</title><link>https://xzygis.github.io/posts/usage-of-docker-container/</link><pubDate>Thu, 30 Jan 2020 13:01:19 +0000</pubDate><guid>https://xzygis.github.io/posts/usage-of-docker-container/</guid><category domain="https://xzygis.github.io/categories/docker/">Docker</category><description>获取镜像 1 $ docker pull ubuntu 启动容器： 1 2 $ docker run -it ubuntu /bin/bash # 要退出终端，直接输入 exit 启动已停止运行的容器 1 $ docker ps -a 启动已停止运行的容器 1 $ docker start b750bbbcfd88 后台运行 1 $ docker run -itd --name ubuntu-test ubuntu /bin/bash 停止一个容器 1 $ docker stop &amp;lt;容器 ID&amp;gt; 停止的容器可以通过 docker restart 重启： 1 $ docker restart &amp;lt;容器 ID&amp;gt; 进入容器 在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器</description></item><item><title>Docker之镜像使用</title><link>https://xzygis.github.io/posts/usage-of-docker-image/</link><pubDate>Thu, 30 Jan 2020 12:58:32 +0000</pubDate><guid>https://xzygis.github.io/posts/usage-of-docker-image/</guid><category domain="https://xzygis.github.io/categories/docker/">Docker</category><description>获取镜像 用法： 1 $ docker pull [OPTIONS] NAME[:TAG|@DIGEST] 例如：docker pull ubuntu:18.04 启动容器 1 $ docker run -it --rm ubuntu:18.04 bash 简要的说明一下上面用到的参数: -it：这是两个参数，一个是 -i表示交互式操作，一个是-t表示终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 --rm：这个参数是说容器退出后随之将其删除。默认情况下，为</description></item><item><title>CentOS安装docker</title><link>https://xzygis.github.io/posts/centos-install-docker/</link><pubDate>Thu, 30 Jan 2020 12:56:35 +0000</pubDate><guid>https://xzygis.github.io/posts/centos-install-docker/</guid><category domain="https://xzygis.github.io/categories/docker/">Docker</category><description>1. 移除旧的版本 1 2 3 4 5 6 7 8 9 10 sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine 2. 安装一些必要的系统工具 1 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 3. 添加软件源信息 1 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 4. 更新 yum 缓存 1 sudo yum makecache fast 5. 安装 Docker-ce 1 sudo yum -y install docker-ce 6. 启动 Docker 后台服务 1 sudo systemctl start docker 7. 测试运行 hello-world 初次运行可能会报如下的错误信息： 1 2 3 4 [root@VM_0_6_centos ~]# docker run hello-world Unable to find image &amp;#39;hello-world:latest&amp;#39; locally docker: Error response from daemon: Get https://registry-1.docker.io/v2/library/hello-world/manifests/latest:</description></item><item><title>SO_REUSEADDR &amp; SO_REUSEPORT</title><link>https://xzygis.github.io/posts/so-reuseaddr-so-reuseport/</link><pubDate>Thu, 30 Jan 2020 12:50:51 +0000</pubDate><guid>https://xzygis.github.io/posts/so-reuseaddr-so-reuseport/</guid><description>SO_REUSEADDR 当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启动的程序的socket2要占用该地址和端口，你的程序就要用到该选项。 SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但每个实例绑定的IP地址是不能相同的。在有多块网卡或用IP Alias技</description></item><item><title>Kubernetes概述</title><link>https://xzygis.github.io/posts/introduction-of-k8s/</link><pubDate>Wed, 29 Jan 2020 23:53:11 +0000</pubDate><guid>https://xzygis.github.io/posts/introduction-of-k8s/</guid><category domain="https://xzygis.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</category><description>Kubernetes 简介 Kubernetes 是谷歌开源的容器集群管理系统，是 Google 多年大规模容器管理技术 Borg 的开源版本，主要功能包括： 基于容器的应用部署、维护和滚动升级 负载均衡和服务发现 跨机器和跨地区的集群调度 自动伸缩 无状态服务和有状态服务 广泛的 Volume 支持 插件机制保证扩展性 Kubernetes 是一个平台 Kubernetes 提供了很多的功能，它可以简化应用程序的工作流，加快开发速度</description></item><item><title>云原生概述</title><link>https://xzygis.github.io/posts/introduction-of-cloud-native/</link><pubDate>Tue, 28 Jan 2020 15:05:10 +0000</pubDate><guid>https://xzygis.github.io/posts/introduction-of-cloud-native/</guid><category domain="https://xzygis.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</category><description>云原生的定义 云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。 这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁</description></item><item><title>Service Mesh概述</title><link>https://xzygis.github.io/posts/introduction-of-service-mesh/</link><pubDate>Tue, 28 Jan 2020 14:48:01 +0000</pubDate><guid>https://xzygis.github.io/posts/introduction-of-service-mesh/</guid><category domain="https://xzygis.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</category><description>什么是服务网格？ 服务网格是用于处理服务间通信的专用基础设施层。它负责通过包含现代云原生应用程序的复杂服务拓扑来可靠地传递请求。实际上，服务网格通常通过一组轻量级网络代理来实现，这些代理与应用程序代码一起部署，而不需要感知应用程序本身。 服务网格的特点 服务网格有如下几个特点： 应用程序间通讯的中间层 轻量级</description></item><item><title>API网关概述</title><link>https://xzygis.github.io/posts/introduction-of-api-gateway/</link><pubDate>Mon, 27 Jan 2020 22:51:43 +0000</pubDate><guid>https://xzygis.github.io/posts/introduction-of-api-gateway/</guid><category domain="https://xzygis.github.io/categories/http/">HTTP</category><description>1 背景 由于后端的微服务拆分，客户端通常需要请求多个服务获取所需数据。 不同客户端所需要的数据不一样。例如，PC需要的数据通常比移动端更加详细。 不同客户端网络环境差异大。例如，WAN vs LAN，移动网络 vs 非移动网络。 服务端实例的地址信息（IP + port）会动态更新。 微服务的拆分逻辑会变化，这种变化应该应该</description></item><item><title>如何通过GitHub+Hexo搭建博客</title><link>https://xzygis.github.io/posts/how-to-create-a-hexo-blog/</link><pubDate>Mon, 27 Jan 2020 21:52:50 +0000</pubDate><guid>https://xzygis.github.io/posts/how-to-create-a-hexo-blog/</guid><category domain="https://xzygis.github.io/categories/%E5%8D%9A%E5%AE%A2/">博客</category><description>安装Node 1 $ brew install node 安装Hexo 1 $ npm install -g hexo 初始化Hexo 1 $ hexo init 生成网页文件和开启服务器 1 2 $ hexo g $ hexo s 关联Github 修改_config.yml，修改deploy为： 1 2 3 4 deploy: type: &amp;#39;git&amp;#39; repository: https://github.com/xzygis/xzygis.github.io.git branch: master 生成静态文件并上传Github 1 2 $ hexo g $ hexo d 若执行hexo d出错则执行npm install hexo-deployer-git --save。 执行hex</description></item></channel></rss>