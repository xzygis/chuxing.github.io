<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - 楚兴的技术笔记</title><link>https://xzygis.github.io/posts/</link><description>所有文章 | 楚兴的技术笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>xzygis@163.com (chuxing)</managingEditor><webMaster>xzygis@163.com (chuxing)</webMaster><lastBuildDate>Wed, 12 Apr 2023 21:08:02 +0800</lastBuildDate><atom:link href="https://xzygis.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>ES数据建模之关联关系处理</title><link>https://xzygis.github.io/posts/es-modeling-your-data/</link><pubDate>Wed, 12 Apr 2023 21:08:02 +0800</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/es-modeling-your-data/</guid><description><![CDATA[<p>现实世界有很多重要的关联关系：博客帖子有一些评论，银行账户有多次交易记录，客户有多个银行账户，订单有多个订单明细，文件目录有多个文件和子目录。</p>
<h2 id="内部对象数组">内部对象数组</h2>
<p>考虑包含内部对象的数组是如何被索引的。 假设我们有个 followers 数组：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;followers&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="nt">&#34;age&#34;</span><span class="p">:</span> <span class="mi">35</span><span class="p">,</span> <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Mary White&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="nt">&#34;age&#34;</span><span class="p">:</span> <span class="mi">26</span><span class="p">,</span> <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Alex Jones&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="nt">&#34;age&#34;</span><span class="p">:</span> <span class="mi">19</span><span class="p">,</span> <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Lisa Smith&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个文档会像我们之前描述的那样被扁平化处理，结果如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;followers.age&#34;</span><span class="p">:</span>    <span class="p">[</span><span class="mi">19</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">35</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;followers.name&#34;</span><span class="p">:</span>   <span class="p">[</span><span class="err">alex</span><span class="p">,</span> <span class="err">jones</span><span class="p">,</span> <span class="err">lisa</span><span class="p">,</span> <span class="err">smith</span><span class="p">,</span> <span class="err">mary</span><span class="p">,</span> <span class="err">white</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>{age: 35}</code> 和 <code>{name: Mary White}</code> 之间的相关性已经丢失了，因为每个多值域只是一包无序的值，而不是有序数组。</p>
<h2 id="嵌套对象">嵌套对象</h2>
<p>由于在 Elasticsearch 中单个文档的增删改都是原子性操作,那么将相关实体数据都存储在同一文档中也就理所当然。 比如说,我们可以将订单及其明细数据存储在一个文档中。又比如,我们可以将一篇博客文章的评论以一个 comments 数组的形式和博客文章放在一起：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="err">PUT</span> <span class="err">/my_index/blogpost/</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;title&#34;</span><span class="p">:</span> <span class="s2">&#34;Nest eggs&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;body&#34;</span><span class="p">:</span>  <span class="s2">&#34;Making your money work...&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;tags&#34;</span><span class="p">:</span>  <span class="p">[</span> <span class="s2">&#34;cash&#34;</span><span class="p">,</span> <span class="s2">&#34;shares&#34;</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments&#34;</span><span class="p">:</span> <span class="p">[</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;name&#34;</span><span class="p">:</span>    <span class="s2">&#34;John Smith&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;comment&#34;</span><span class="p">:</span> <span class="s2">&#34;Great article&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;age&#34;</span><span class="p">:</span>     <span class="mi">28</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;stars&#34;</span><span class="p">:</span>   <span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;date&#34;</span><span class="p">:</span>    <span class="s2">&#34;2014-09-01&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;name&#34;</span><span class="p">:</span>    <span class="s2">&#34;Alice White&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;comment&#34;</span><span class="p">:</span> <span class="s2">&#34;More like this please&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;age&#34;</span><span class="p">:</span>     <span class="mi">31</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;stars&#34;</span><span class="p">:</span>   <span class="mi">5</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;date&#34;</span><span class="p">:</span>    <span class="s2">&#34;2014-10-22&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们依赖字段自动映射,那么 comments 字段会自动映射为 object 类型。</p>
<p>由于所有的信息都在一个文档中,当我们查询时就没有必要去联合文章和评论文档,查询效率就很高。但是因为JSON 格式的文档被处理成如下的扁平式键值对的结构，会导致查询结果不准确。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;title&#34;</span><span class="p">:</span>            <span class="p">[</span> <span class="err">eggs</span><span class="p">,</span> <span class="err">nest</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;body&#34;</span><span class="p">:</span>             <span class="p">[</span> <span class="err">making</span><span class="p">,</span> <span class="err">money</span><span class="p">,</span> <span class="err">work</span><span class="p">,</span> <span class="err">your</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;tags&#34;</span><span class="p">:</span>             <span class="p">[</span> <span class="err">cash</span><span class="p">,</span> <span class="err">shares</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.name&#34;</span><span class="p">:</span>    <span class="p">[</span> <span class="err">alice</span><span class="p">,</span> <span class="err">john</span><span class="p">,</span> <span class="err">smith</span><span class="p">,</span> <span class="err">white</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.comment&#34;</span><span class="p">:</span> <span class="p">[</span> <span class="err">article</span><span class="p">,</span> <span class="err">great</span><span class="p">,</span> <span class="err">like</span><span class="p">,</span> <span class="err">more</span><span class="p">,</span> <span class="err">please</span><span class="p">,</span> <span class="err">this</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.age&#34;</span><span class="p">:</span>     <span class="p">[</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">31</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.stars&#34;</span><span class="p">:</span>   <span class="p">[</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.date&#34;</span><span class="p">:</span>    <span class="p">[</span> <span class="mi">2014-09-01</span><span class="p">,</span> <span class="mi">2014-10-22</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>嵌套对象 就是来解决这个问题的。将 comments 字段类型设置为 nested 而不是 object 后,每一个嵌套对象都会被索引为一个 隐藏的独立文档 ,举例如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.name&#34;</span><span class="p">:</span>    <span class="p">[</span> <span class="err">john</span><span class="p">,</span> <span class="err">smith</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.comment&#34;</span><span class="p">:</span> <span class="p">[</span> <span class="err">article</span><span class="p">,</span> <span class="err">great</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.age&#34;</span><span class="p">:</span>     <span class="p">[</span> <span class="mi">28</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.stars&#34;</span><span class="p">:</span>   <span class="p">[</span> <span class="mi">4</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.date&#34;</span><span class="p">:</span>    <span class="p">[</span> <span class="mi">2014-09-01</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.name&#34;</span><span class="p">:</span>    <span class="p">[</span> <span class="err">alice</span><span class="p">,</span> <span class="err">white</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.comment&#34;</span><span class="p">:</span> <span class="p">[</span> <span class="err">like</span><span class="p">,</span> <span class="err">more</span><span class="p">,</span> <span class="err">please</span><span class="p">,</span> <span class="err">this</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.age&#34;</span><span class="p">:</span>     <span class="p">[</span> <span class="mi">31</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.stars&#34;</span><span class="p">:</span>   <span class="p">[</span> <span class="mi">5</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;comments.date&#34;</span><span class="p">:</span>    <span class="p">[</span> <span class="mi">2014-10-22</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;title&#34;</span><span class="p">:</span>            <span class="p">[</span> <span class="err">eggs</span><span class="p">,</span> <span class="err">nest</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;body&#34;</span><span class="p">:</span>             <span class="p">[</span> <span class="err">making</span><span class="p">,</span> <span class="err">money</span><span class="p">,</span> <span class="err">work</span><span class="p">,</span> <span class="err">your</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;tags&#34;</span><span class="p">:</span>             <span class="p">[</span> <span class="err">cash</span><span class="p">,</span> <span class="err">shares</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>第一个和第二个为嵌套文档，第三个为根文档。</p>
<p>在独立索引每一个嵌套对象后,对象中每个字段的相关性得以保留。我们查询时,也仅仅返回那些真正符合条件的文档。</p>
<p>不仅如此,由于嵌套文档直接存储在文档内部,查询时嵌套文档和根文档联合成本很低,速度和单独存储几乎一样。</p>
<p>嵌套文档是隐藏存储的,我们不能直接获取。如果要增删改一个嵌套对象,我们必须把整个文档重新索引才可以。值得注意的是,查询的时候返回的是整个文档,而不是嵌套文档本身。</p>
<h2 id="父-子关系文档">父-子关系文档</h2>
<p>父-子关系文档 在实质上类似于 nested model（嵌套对象） ：允许将一个对象实体和另外一个对象实体关联起来。而这两种类型的主要区别是：在 nested objects 文档中，所有对象都是在同一个文档中，而在父-子关系文档中，父对象和子对象都是完全独立的文档。</p>
<p>父-子关系的主要作用是允许把一个 type 的文档和另外一个 type 的文档关联起来，构成一对多的关系：一个父文档可以对应多个子文档 。与 nested objects 相比，父-子关系的主要优势有：</p>
<ul>
<li>
<p>更新父文档时，不会重新索引子文档。</p>
</li>
<li>
<p>创建，修改或删除子文档时，不会影响父文档或其他子文档。这一点在这种场景下尤其有用：子文档数量较多，并且子文档创建和修改的频率高时。</p>
</li>
<li>
<p>子文档可以作为搜索结果独立返回。</p>
</li>
<li>
<p>Elasticsearch 维护了一个父文档和子文档的映射关系，得益于这个映射，父-子文档关联查询操作非常快。但是这个映射也对父-子文档关系有个限制条件：父文档和其所有子文档，都必须要存储在同一个分片中。</p>
</li>
</ul>
]]></description></item><item><title>Redis 复制</title><link>https://xzygis.github.io/posts/introduction-to-redis-replication/</link><pubDate>Wed, 01 Feb 2023 22:13:25 +0800</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/introduction-to-redis-replication/</guid><description><![CDATA[<p>在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）。</p>
<p>进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“数据库状态一致”，或者简称“一致”。</p>
<h2 id="旧版复制功能的实现1">旧版复制功能的实现<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></h2>
<p>Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作：</p>
<ul>
<li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</li>
<li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。</li>
</ul>
<h3 id="同步">同步</h3>
<p>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</p>
<p>从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：</p>
<ul>
<li>从服务器向主服务器发送SYNC命令。</li>
<li>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。</li>
<li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。</li>
<li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。</li>
</ul>
<p></p>
<h3 id="命令传播">命令传播</h3>
<p>在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致。</p>
<p>为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。</p>
<h2 id="旧版复制功能的缺陷">旧版复制功能的缺陷</h2>
<p>在Redis中，从服务器对主服务器的复制可以分为以下两种情况：</p>
<ul>
<li>初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。</li>
<li>断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。</li>
</ul>
<p>对于初次复制来说，旧版复制功能能够很好地完成任务，但对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低。</p>
<p>主从服务器断开的时间越短，主服务器在断线期间执行的写命令就越少，而执行少量写命令所产生的数据量通常比整个数据库的数据量要少得多，在这种情况下，为了让从服务器补足一小部分缺失的数据，却要让主从服务器重新执行一次SYNC命令，这种做法无疑是非常低效的。</p>
<h2 id="新版复制功能的实现">新版复制功能的实现</h2>
<p>为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作。PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式：</p>
<ul>
<li>其中完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。</li>
<li>而部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。</li>
</ul>
<p>虽然SYNC命令和PSYNC命令都可以让断线的主从服务器重新回到一致状态，但执行部分重同步所需的资源比起执行SYNC命令所需的资源要少得多，完成同步的速度也快得多。执行SYNC命令需要生成、传送和载入整个RDB文件，而部分重同步只需要将从服务器缺少的写命令发送给从服务器执行就可以了。</p>
<h2 id="部分重同步的实现">部分重同步的实现</h2>
<p>部分重同步功能由以下三个部分构成：</p>
<ul>
<li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。</li>
<li>主服务器的复制积压缓冲区（replication backlog）。</li>
<li>服务器的运行ID（run ID）。</li>
</ul>
<h3 id="复制偏移量">复制偏移量</h3>
<p>执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量：</p>
<ul>
<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。</li>
<li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。</li>
</ul>
<p>通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态：</p>
<ul>
<li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的。</li>
<li>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态。</li>
</ul>
<h3 id="复制积压缓冲区">复制积压缓冲区</h3>
<p>复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。</p>
<p>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面：
</p>
<p>因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。</p>
<p>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：</p>
<ul>
<li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作。</li>
<li>相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。</li>
</ul>
<p>为了安全起见，可以将复制积压缓冲区的大小设为<code>2*second*write_size_per_second</code>，这样可以保证绝大部分断线情况都能用部分重同步来处理。</p>
<h3 id="服务器运行id">服务器运行ID</h3>
<p>除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行ID（run ID）：</p>
<ul>
<li>每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID。</li>
<li>运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。</li>
</ul>
<p>当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来。</p>
<p>当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：</p>
<ul>
<li>如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作。</li>
<li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。</li>
</ul>
<h2 id="psync命令的实现">PSYNC命令的实现</h2>
<p>PSYNC命令的调用方法有两种：</p>
<ul>
<li>如果从服务器以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器进行完整重同步（因为这时不可能执行部分重同步）。</li>
<li>相反地，如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ＜runid＞ ＜offset＞命令：其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作。</li>
</ul>
<p>根据情况，接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：</p>
<ul>
<li>如果主服务器返回+FULLRESYNC ＜runid＞ ＜offset＞回复，那么表示主服务器将与从服务器执行完整重同步操作：其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量。</li>
<li>如果主服务器返回+CONTINUE回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了。</li>
<li>如果主服务器返回-ERR回复，那么表示主服务器的版本低于Redis 2.8，它识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作。</li>
</ul>
<p></p>
<h2 id="复制的实现">复制的实现</h2>
<h3 id="步骤1设置主服务器的地址和端口">步骤1：设置主服务器的地址和端口</h3>
<p>当客户端向从服务器发送以下命令时：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">127.0.0.1:12345＞ SLAVEOF 127.0.0.1 <span class="m">6379</span>
</span></span><span class="line"><span class="cl">OK
</span></span></code></pre></td></tr></table>
</div>
</div><p>从服务器首先要做的就是将客户端给定的主服务器IP地址127.0.0.1以及端口6379保存到服务器状态的masterhost属性和masterport属性里面：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//主服务器的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="o">*</span><span class="n">masterhost</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//主服务器的端口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">masterport</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>SLAVEOF命令是一个异步命令，在完成masterhost属性和masterport属性的设置工作之后，从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而实际的复制工作将在OK返回之后才真正开始执行。</p>
<h3 id="步骤2建立套接字连接">步骤2：建立套接字连接</h3>
<p>在SLAVEOF命令执行之后，从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接。</p>
<p>如果从服务器创建的套接字能成功连接（connect）到主服务器，那么从服务器将为这个套接字关联一个专门用于处理复制工作的文件事件处理器，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令，诸如此类。</p>
<p>而主服务器在接受（accept）从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，这时从服务器将同时具有服务器（server）和客户端（client）两个身份：从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复。</p>
<h3 id="步骤3发送ping命令">步骤3：发送PING命令</h3>
<p>从服务器成为主服务器的客户端之后，做的第一件事就是向主服务器发送一个PING命令，这个PING命令有两个作用：</p>
<ul>
<li>虽然主从服务器成功建立起了套接字连接，但双方并未使用该套接字进行过任何通信，通过发送PING命令可以检查套接字的读写状态是否正常。</li>
<li>因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送PING命令可以检查主服务器能否正常处理命令请求。</li>
</ul>
<h3 id="步骤4身份验证">步骤4：身份验证</h3>
<p>服务器在收到主服务器返回的&quot;PONG&quot;回复之后，下一步要做的就是决定是否进行身份验证：</p>
<ul>
<li>如果从服务器设置了masterauth选项，那么进行身份验证。</li>
<li>如果从服务器没有设置masterauth选项，那么不进行身份验证。</li>
</ul>
<p>在需要进行身份验证的情况下，从服务器将向主服务器发送一条AUTH命令，命令的参数为从服务器masterauth选项的值。</p>
<h3 id="步骤5发送端口信息">步骤5：发送端口信息</h3>
<p>在身份验证步骤之后，从服务器将执行命令<code>REPLCONF listening-port ＜port-number＞</code>，向主服务器发送从服务器的监听端口号。
主服务器在接收到这个命令之后，会将端口号记录在从服务器所对应的客户端状态的slave_listening_port属性中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisClient</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//从服务器的监听端口号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">slave_listening_port</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">redisClient</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>slave_listening_port属性目前唯一的作用就是在主服务器执行INFO replication命令时打印出从服务器的端口号。</p>
<h3 id="步骤6同步">步骤6：同步</h3>
<p>在这一步，从服务器将向主服务器发送PSYNC命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态。</p>
<p>在同步操作执行之后，主从服务器双方都是对方的客户端，它们可以互相向对方发送命令请求，或者互相向对方返回命令回复。</p>
<h3 id="步骤7命令传播">步骤7：命令传播</h3>
<p>当完成了同步之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了。</p>
<h2 id="心跳检测">心跳检测</h2>
<p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">REPLCONF ACK ＜replication_offset＞
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中replication_offset是从服务器当前的复制偏移量。发送REPLCONF ACK命令对于主从服务器有三个作用：</p>
<ul>
<li>检测主从服务器的网络连接状态。</li>
<li>辅助实现min-slaves选项。</li>
<li>检测命令丢失。</li>
</ul>
<p>如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p>
<h2 id="重点回顾">重点回顾</h2>
<ul>
<li>Redis 2.8以前的复制功能不能高效地处理断线后重复制情况，但Redis 2.8新添加的部分重同步功能可以解决这个问题。</li>
<li>部分重同步通过复制偏移量、复制积压缓冲区、服务器运行ID三个部分来实现。</li>
<li>在复制操作刚开始的时候，从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来执行复制步骤，而在复制操作的后期，主从服务器会互相成为对方的客户端。</li>
<li>主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致，而从服务器则通过向主服务器发送命令来进行心跳检测，以及命令丢失检测。</li>
</ul>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>《Redis设计与实现》&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></description></item><item><title>Redis 事件</title><link>https://xzygis.github.io/posts/introduction-to-redis-event/</link><pubDate>Wed, 01 Feb 2023 21:34:52 +0800</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/introduction-to-redis-event/</guid><description><![CDATA[<p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p>
<ul>
<li>文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li>
<li>时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li>
</ul>
<h2 id="文件事件">文件事件</h2>
<p>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：</p>
<ul>
<li>文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p>
<h3 id="文件事件处理器的构成">文件事件处理器的构成</h3>
<p>下图展示了文件事件处理器的四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。
</p>
<p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。</p>
<p>I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。</p>
<p>文件事件分派器接收I/O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。</p>
<p>服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，它们定义了某个事件发生时，服务器应该执行的动作。</p>
<h3 id="io多路复用程序的实现">I/O多路复用程序的实现</h3>
<p>Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c，诸如此类。</p>
<p>因为Redis为每个I/O多路复用函数库都实现了相同的API，所以I/O多路复用程序的底层实现是可以互换的。</p>
<p>Redis在I/O多路复用程序的实现源码中用#include宏定义了相应的规则，程序会在编译时自动选择系统中性能最高的I/O多路复用函数库来作为Redis的I/O多路复用程序的底层实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Include the best multiplexing layer supported by this system.
</span></span></span><span class="line"><span class="cl"><span class="cm">* The following should be ordered by performances, descending. */</span>
</span></span><span class="line"><span class="cl"><span class="cp"># ifdef HAVE_EVPORT
</span></span></span><span class="line"><span class="cl"><span class="cp"># include &#34;ae_evport.c&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp"># else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp"># ifdef HAVE_EPOLL
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp"># include &#34;ae_epoll.c&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp"># else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp"># ifdef HAVE_KQUEUE
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp"># include &#34;ae_kqueue.c&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp"># else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp"># include &#34;ae_select.c&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp"># endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp"># endif
</span></span></span><span class="line"><span class="cl"><span class="cp"># endif
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="事件的类型">事件的类型</h3>
<p>I/O多路复用程序可以监听多个套接字的ae.h/AE_READABLE事件和ae.h/AE_WRITABLE事件，这两类事件和套接字操作之间的对应关系如下：</p>
<ul>
<li>当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作），套接字产生AE_READABLE事件。</li>
<li>当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件。</li>
</ul>
<p>I/O多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITABLE事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件，等到AE_READABLE事件处理完之后，才处理AE_WRITABLE事件。</p>
<h3 id="api">API</h3>
<p>ae.c/aeCreateFileEvent函数接受一个套接字描述符、一个事件类型，以及一个事件处理器作为参数，将给定套接字的给定事件加入到I/O多路复用程序的监听范围之内，并对事件和事件处理器进行关联。</p>
<p>ae.c/aeDeleteFileEvent函数接受一个套接字描述符和一个监听事件类型作为参数，让I/O多路复用程序取消对给定套接字的给定事件的监听，并取消事件和事件处理器之间的关联。</p>
<p>ae.c/aeGetFileEvents函数接受一个套接字描述符，返回该套接字正在被监听的事件类型:</p>
<ul>
<li>如果套接字没有任何事件被监听，那么函数返回AE_NONE。</li>
<li>如果套接字的读事件正在被监听，那么函数返回AE_READABLE。</li>
<li>如果套接字的写事件正在被监听，那么函数返回AE_WRITABLE。</li>
<li>如果套接字的读事件和写事件正在被监听，那么函数返回AE_READABLE|AE_WRITABLE。</li>
</ul>
<p>ae.c/aeWait函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数，在给定的时间内阻塞并等待套接字的给定类型事件产生，当事件成功产生，或者等待超时之后，函数返回。</p>
<p>ae.c/aeApiPoll函数接受一个sys/time.h/struct timeval结构为参数，并在指定的时间內，阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字产生文件事件，当有至少一个事件产生，或者等待超时后，函数返回。</p>
<p>ae.c/aeProcessEvents函数是<strong>文件事件分派器</strong>，它先调用aeApiPoll函数来等待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件。</p>
<h3 id="文件事件的处理器">文件事件的处理器</h3>
<p>Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求:</p>
<ul>
<li>为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。</li>
<li>为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。</li>
<li>为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。</li>
<li>当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。</li>
</ul>
<h2 id="时间事件">时间事件</h2>
<p>Redis的时间事件分为以下两类：</p>
<ul>
<li>定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次。</li>
<li>周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。</li>
</ul>
<p>一个时间事件主要由以下三个属性组成：</p>
<ul>
<li>id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</li>
<li>when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间。</li>
<li>timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li>
</ul>
<p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:</p>
<ul>
<li>如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达。</li>
<li>如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。</li>
</ul>
<p>目前版本的Redis只使用周期性事件，而没有使用定时事件。</p>
<h3 id="实现">实现</h3>
<p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
<p>注意，我们说保存时间事件的链表为无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序。正因为链表没有按when属性进行排序，所以当时间事件执行器运行的时候，它必须遍历链表中的所有时间事件，这样才能确保服务器中所有已到达的时间事件都会被处理。</p>
<p>无序链表并不影响时间事件处理器的性能。在目前版本中，正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件。在这种情况下，服务器几乎是将无序链表退化成一个指针来使用，所以使用无序链表来保存时间事件，并不影响事件执行的性能。</p>
<h3 id="api-1">API</h3>
<p>ae.c/aeCreateTimeEvent函数接受一个毫秒数milliseconds和一个时间事件处理器proc作为参数，将一个新的时间事件添加到服务器，这个新的时间事件将在当前时间的milliseconds毫秒之后到达，而事件的处理器为proc。</p>
<p>ae.c/aeDeleteFileEvent函数接受一个时间事件ID作为参数，然后从服务器中删除该ID所对应的时间事件。</p>
<p>ae.c/aeSearchNearestTimer函数返回到达时间距离当前时间最接近的那个时间事件。</p>
<p>ae.c/processTimeEvents函数是时间事件的执行器，这个函数会遍历所有已到达的时间事件，并调用这些事件的处理器。已到达指的是，时间事件的when属性记录的UNIX时间戳等于或小于当前时间的UNIX时间戳。</p>
<p>processTimeEvents函数的定义可以用以下伪代码来描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">processTimeEvents</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#遍历服务器中的所有时间事件</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">time_event</span> <span class="ow">in</span> <span class="n">all_time_event</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#检查事件是否已经到达</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">time_event</span><span class="o">.</span><span class="n">when</span> <span class="err">＜</span><span class="o">=</span> <span class="n">unix_ts_now</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">            <span class="c1">#事件已到达</span>
</span></span><span class="line"><span class="cl">            <span class="c1">#执行事件处理器，并获取返回值</span>
</span></span><span class="line"><span class="cl">            <span class="n">retval</span> <span class="o">=</span> <span class="n">time_event</span><span class="o">.</span><span class="n">timeProc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="c1">#如果这是一个定时事件</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">retval</span> <span class="o">==</span> <span class="n">AE_NOMORE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="c1">#那么将该事件从服务器中删除</span>
</span></span><span class="line"><span class="cl">                <span class="n">delete_time_event_from_server</span><span class="p">(</span><span class="n">time_event</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#如果这是一个周期性事件</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">#那么按照事件处理器的返回值更新时间事件的 when属性</span>
</span></span><span class="line"><span class="cl">            <span class="c1">#让这个事件在指定的时间之后再次到达</span>
</span></span><span class="line"><span class="cl">            <span class="n">update_when</span><span class="p">(</span><span class="n">time_event</span><span class="p">,</span> <span class="n">retval</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="时间事件应用实例servercron函数">时间事件应用实例：serverCron函数</h3>
<p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c/serverCron函数负责执行，它的主要工作包括：</p>
<ul>
<li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li>
<li>清理数据库中的过期键值对。</li>
<li>关闭和清理连接失效的客户端。</li>
<li>尝试进行AOF或RDB持久化操作。</li>
<li>如果服务器是主服务器，那么对从服务器进行定期同步。</li>
<li>如果处于集群模式，对集群进行定期同步和连接测试。</li>
</ul>
<p>Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每隔一段时间，serverCron就会执行一次，直到服务器关闭为止。</p>
<p>在Redis2.6版本，服务器默认规定serverCron每秒运行10次，平均每间隔100毫秒运行一次。</p>
<h2 id="事件的调度与执行">事件的调度与执行</h2>
<p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们等等。</p>
<p>事件的调度和执行由ae.c/aeProcessEvents函数负责，以下是该函数的伪代码表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">aeProcessEvents</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#获取到达时间离当前时间最接近的时间事件</span>
</span></span><span class="line"><span class="cl">    <span class="n">time_event</span> <span class="o">=</span> <span class="n">aeSearchNearestTimer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#计算最接近的时间事件距离到达还有多少毫秒</span>
</span></span><span class="line"><span class="cl">    <span class="n">remaind_ms</span> <span class="o">=</span> <span class="n">time_event</span><span class="o">.</span><span class="n">when</span> <span class="o">-</span> <span class="n">unix_ts_now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#如果事件已到达，那么remaind_ms的值可能为负数，将它设定为0</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">remaind_ms</span> <span class="err">＜</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">remaind_ms</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#根据remaind_ms的值，创建timeval结构</span>
</span></span><span class="line"><span class="cl">    <span class="n">timeval</span> <span class="o">=</span> <span class="n">create_timeval_with_ms</span><span class="p">(</span><span class="n">remaind_ms</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#如果remaind_ms的值为0，那么aeApiPoll调用之后马上返回，不阻塞</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeApiPoll</span><span class="p">(</span><span class="n">timeval</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#处理所有已产生的文件事件</span>
</span></span><span class="line"><span class="cl">    <span class="n">processFileEvents</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#处理所有已到达的时间事件</span>
</span></span><span class="line"><span class="cl">    <span class="n">processTimeEvents</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将aeProcessEvents函数置于一个循环里面，加上初始化和清理函数，这就构成了Redis服务器的主函数，以下是该函数的伪代码表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#初始化服务器</span>
</span></span><span class="line"><span class="cl">    <span class="n">init_server</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#一直处理事件，直到服务器关闭为止</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">server_is_not_shutdown</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="n">aeProcessEvents</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#服务器关闭，执行清理操作</span>
</span></span><span class="line"><span class="cl">    <span class="n">clean_server</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>以下是事件的调度和执行规则：</p>
<ul>
<li>aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保aeApiPoll函数不会阻塞过长时间。</li>
<li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了。</li>
<li>对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。比如说，在命令回复处理器将一个命令回复写入到客户端套接字时，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写入循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</li>
<li>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些。</li>
</ul>
<h2 id="重点回顾">重点回顾</h2>
<ul>
<li>Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类。</li>
<li>文件事件处理器是基于Reactor模式实现的网络通信程序。</li>
<li>文件事件是对套接字操作的抽象：每次套接字变为可应答（acceptable）、可写（writable）或者可读（readable）时，相应的文件事件就会产生。</li>
<li>文件事件分为AE_READABLE事件（读事件）和AE_WRITABLE事件（写事件）两类。</li>
<li>时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。</li>
<li>服务器在一般情况下只执行serverCron函数一个时间事件，并且这个事件是周期性事件。</li>
<li>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。❑时间事件的实际处理时间通常会比设定的到达时间晚一些。</li>
</ul>
]]></description></item><item><title>Redis 服务器</title><link>https://xzygis.github.io/posts/introduction-to-redis-server/</link><pubDate>Wed, 21 Dec 2022 19:42:15 +0800</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/introduction-to-redis-server/</guid><description><![CDATA[<p>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p>
<h2 id="命令请求的执行过程">命令请求的执行过程</h2>
<h3 id="发送命令请求">发送命令请求</h3>
<p>Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器。</p>
<p></p>
<p>举个例子，假设用户在客户端键入了命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">SET KEY VALUE
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么客户端会将这个命令转换成协议：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">*3<span class="se">\r\n</span><span class="nv">$3</span><span class="se">\r\n</span>SET<span class="se">\r\n</span><span class="nv">$3</span><span class="se">\r\n</span>KEY<span class="se">\r\n</span><span class="nv">$5</span><span class="se">\r\n</span>VALUE<span class="se">\r\n</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后将这段协议内容发送给服务器。</p>
<h3 id="读取命令请求">读取命令请求</h3>
<p>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作：</p>
<ol>
<li>读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。</li>
<li>对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</li>
<li>调用命令执行器，执行客户端指定的命令。</li>
</ol>
<h3 id="命令执行器1查找命令实现">命令执行器（1）：查找命令实现</h3>
<p>命令执行器要做的第一件事就是根据客户端状态的argv[0]参数，在命令表（command table）中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。</p>
<p>命令表是一个字典，字典的键是一个个命令名字，比如&quot;set&quot;、&ldquo;get&rdquo;、&ldquo;del&quot;等等；而字典的值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息。</p>
<p>因为命令表使用的是大小写无关的查找算法，无论输入的命令名字是大写、小写或者混合大小写，只要命令的名字是正确的，就能找到相应的redisCommand结构。</p>
<h3 id="命令执行器2执行预备操作">命令执行器（2）：执行预备操作</h3>
<p>到目前为止，服务器已经将执行命令所需的命令实现函数（保存在客户端状态的cmd属性）、参数（保存在客户端状态的argv属性）、参数个数（保存在客户端状态的argc属性）都收集齐了，但是在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令可以正确、顺利地被执行，这些操作包括：</p>
<ul>
<li>检查客户端状态的cmd指针是否指向NULL，如果是的话，那么说明用户输入的命令名字找不到相应的命令实现，服务器不再执行后续步骤，并向客户端返回一个错误。</li>
<li>根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误。比如说，如果redisCommand结构的arity属性的值为-3，那么用户输入的命令参数个数必须大于等于3个才行。</li>
<li>检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令，如果未通过身份验证的客户端试图执行除AUTH命令之外的其他命令，那么服务器将向客户端返回一个错误。</li>
<li>如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。如果内存回收失败，那么不再执行后续步骤，向客户端返回一个错误。</li>
<li>如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并向客户端返回一个错误。</li>
<li>如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令，其他命令都会被服务器拒绝。</li>
<li>如果服务器正在进行数据载入，那么客户端发送的命令必须带有l标识（比如INFO、SHUTDOWN、PUBLISH等等）才会被服务器执行，其他命令都会被服务器拒绝。</li>
<li>如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令，其他命令都会被服务器拒绝。</li>
<li>如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中。</li>
<li>如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器。当完成了以上预备操作之后，服务器就可以开始真正执行命令了。</li>
</ul>
<h3 id="命令执行器3调用命令的实现函数">命令执行器（3）：调用命令的实现函数</h3>
<p>在前面的操作中，服务器已经将要执行命令的实现保存到了客户端状态的cmd属性里面，并将命令的参数和参数个数分别保存到了客户端状态的argv属性和argv属性里面，当服务器决定要执行命令时，它只要执行以下语句就可以了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// client是指向客户端状态的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">client</span><span class="o">-</span><span class="err">＞</span><span class="n">cmd</span><span class="o">-</span><span class="err">＞</span><span class="nf">proc</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会被保存在客户端状态的输出缓冲区里面（buf属性和reply属性），之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端。</p>
<h3 id="命令执行器4执行后续工作">命令执行器（4）：执行后续工作</h3>
<p>在执行完实现函数之后，服务器还需要执行一些后续工作：</p>
<ul>
<li>如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。❑</li>
<li>根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。</li>
<li>如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面。</li>
<li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</li>
</ul>
<p>当以上操作都执行完了之后，服务器对于当前命令的执行到此就告一段落了，之后服务器就可以继续从文件事件处理器中取出并处理下一个命令请求了。</p>
<h3 id="将命令回复发送给客户端">将命令回复发送给客户端</h3>
<p>命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。</p>
<p>当命令回复发送完毕之后，回复处理器会清空客户端状态的输出缓冲区，为处理下一个命令请求做好准备。</p>
<h3 id="客户端接收并打印命令回复">客户端接收并打印命令回复</h3>
<p>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看。</p>
<h2 id="servercron函数">serverCron函数</h2>
<p>Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p>
<h3 id="更新服务器时间缓存">更新服务器时间缓存</h3>
<p>Redis服务器中有不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">//保存了秒级精度的系统当前UNIX时间戳
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kt">time_t</span> <span class="n">unixtime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//保存了毫秒级精度的系统当前UNIX时间戳
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kt">long</span> <span class="kt">long</span> <span class="n">mstime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性，所以这两个属性记录的时间的精确度并不高：</p>
<ul>
<li>服务器只会在打印日志、更新服务器的LRU时钟、决定是否执行持久化任务、计算服务器上线时间（uptime）这类对时间精确度要求不高的功能上。</li>
<li>对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间。</li>
</ul>
<h3 id="更新lru时钟">更新LRU时钟</h3>
<p>服务器状态中的lruclock属性保存了服务器的LRU时钟，这个属性和上面介绍的unixtime属性、mstime属性一样，都是服务器时间缓存的一种：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//默认每10秒更新一次的时钟缓存，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//用于计算键的空转（idle）时长。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">lruclock</span><span class="p">:</span><span class="mi">22</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个Redis对象都会有一个lru属性，这个lru属性保存了对象最后一次被命令访问的时间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisObject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">lru</span><span class="p">:</span><span class="mi">22</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">robj</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当服务器要计算一个数据库键的空转时间（也即是数据库键对应的值对象的空转时间），程序会用服务器的lruclock属性记录的时间减去对象的lru属性记录的时间，得出的计算结果就是这个对象的空转时间。</p>
<p>serverCron函数默认会以每10秒一次的频率更新lruclock属性的值，因为这个时钟不是实时的，所以根据这个属性计算出来的LRU时间实际上只是一个模糊的估算值。</p>
<h3 id="更新服务器每秒执行命令次数">更新服务器每秒执行命令次数</h3>
<p>serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量，这个值可以通过INFO status命令的instantaneous_ops_per_sec域查看。</p>
<p>trackOperationsPerSecond函数和服务器状态中四个ops_sec_开头的属性有关：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//上一次进行抽样的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span> <span class="n">ops_sec_last_sample_time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//上一次抽样时，服务器已执行命令的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span> <span class="n">ops_sec_last_sample_ops</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// REDIS_OPS_SEC_SAMPLES大小（默认值为16）的环形数组，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//数组中的每个项都记录了一次抽样结果。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span> <span class="n">ops_sec_samples</span><span class="p">[</span><span class="n">REDIS_OPS_SEC_SAMPLES</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ops_sec_samples数组的索引值，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//每次抽样后将值自增一，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//在值等于16时重置为0，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//让ops_sec_samples数组构成一个环形数组。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">ops_sec_idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>trackOperationsPerSecond函数每次运行，都会根据ops_sec_last_sample_time记录的上一次抽样时间和服务器的当前时间，以及ops_sec_last_sample_ops记录的上一次抽样的已执行命令数量和服务器当前的已执行命令数量，计算出两次trackOperationsPerSecond调用之间，服务器平均每一毫秒处理了多少个命令请求，然后将这个平均值乘以1000，这就得到了服务器在一秒钟内能处理多少个命令请求的估计值，这个估计值会被作为一个新的数组项被放进ops_sec_samples环形数组里面。</p>
<h3 id="更新服务器内存峰值记录">更新服务器内存峰值记录</h3>
<p>服务器状态中的stat_peak_memory属性记录了服务器的内存峰值大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//已使用内存峰值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">size_t</span> <span class="n">stat_peak_memory</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每次serverCron函数执行时，程序都会查看服务器当前使用的内存数量，并与stat_peak_memory保存的数值进行比较，如果当前使用的内存数量比stat_peak_memory属性记录的值要大，那么程序就将当前使用的内存数量记录到stat_peak_memory属性里面。</p>
<h3 id="处理sigterm信号">处理SIGTERM信号</h3>
<p>在启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// SIGTERM信号的处理器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">sigtermHandler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//打印日志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">redisLogFromHandler</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&#34;Received SIGTERM, scheduling shutdown...&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//打开关闭标识
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">server</span><span class="p">.</span><span class="n">shutdown_asap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每次serverCron函数运行时，程序都会对服务器状态的shutdown_asap属性进行检查，并根据属性的值决定是否关闭服务器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//关闭服务器的标识：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//值为1时，关闭服务器，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//值为0时，不做动作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">shutdown_asap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>以下代码展示了服务器在接到SIGTERM信号之后，关闭服务器并打印相关日志的过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="o">[</span><span class="m">6794</span> <span class="p">|</span> signal handler<span class="o">]</span> <span class="o">(</span>1384435690<span class="o">)</span> Received SIGTERM, scheduling shutdown...
</span></span><span class="line"><span class="cl"><span class="o">[</span>6794<span class="o">]</span> <span class="m">14</span> Nov 21:28:10.108 <span class="c1"># User requested shutdown...</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>6794<span class="o">]</span> <span class="m">14</span> Nov 21:28:10.108 * Saving the final RDB snapshot before exiting.
</span></span><span class="line"><span class="cl"><span class="o">[</span>6794<span class="o">]</span> <span class="m">14</span> Nov 21:28:10.161 * DB saved on disk
</span></span><span class="line"><span class="cl"><span class="o">[</span>6794<span class="o">]</span> <span class="m">14</span> Nov 21:28:10.161 <span class="c1"># Redisis now ready to exit, bye bye...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从日志里面可以看到，服务器在关闭自身之前会进行RDB持久化操作，这也是服务器拦截SIGTERM信号的原因，如果服务器一接到SIGTERM信号就立即关闭，那么它就没办法执行持久化操作了。</p>
<h3 id="管理客户端资源">管理客户端资源</h3>
<p>serverCron函数每次执行都会调用clientsCron函数，clientsCron函数会对一定数量的客户端进行以下两个检查：</p>
<ul>
<li>如果客户端与服务器之间的连接已经超时（很长一段时间里客户端和服务器都没有互动），那么程序释放这个客户端。</li>
<li>如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。</li>
</ul>
<h3 id="管理数据库资源">管理数据库资源</h3>
<p>serverCron函数每次执行都会调用databasesCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作。</p>
<h3 id="执行被延迟的bgrewriteaof">执行被延迟的BGREWRITEAOF</h3>
<p>在服务器执行BGSAVE命令的期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后。</p>
<h3 id="检查持久化操作的运行状态">检查持久化操作的运行状态</h3>
<p>服务器状态使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，这两个属性也可以用于检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行。</p>
<p>每次serverCron函数执行时，程序都会检查rdb_child_pid和aof_child_pid两个属性的值，只要其中一个属性的值不为-1，程序就会执行一次wait3函数，检查子进程是否有信号发来服务器进程：</p>
<ul>
<li>如果有信号到达，那么表示新的RDB文件已经生成完毕（对于BGSAVE命令来说），或者AOF文件已经重写完毕（对于BGREWRITEAOF命令来说），服务器需要进行相应命令的后续操作，比如用新的RDB文件替换现有的RDB文件，或者用重写后的AOF文件替换现有的AOF文件。</li>
<li>如果没有信号到达，那么表示持久化操作未完成，程序不做动作。</li>
</ul>
<p>另一方面，如果rdb_child_pid和aof_child_pid两个属性的值都为-1，那么表示服务器没有在进行持久化操作，在这种情况下，程序执行以下三个检查：</p>
<ol>
<li>查看是否有BGREWRITEAOF被延迟了，如果有的话，那么开始一次新的BGREWRITEAOF操作（这就是上一个小节我们说到的检查）。</li>
<li>检查服务器的自动保存条件是否已经被满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器开始一次新的BGSAVE操作（因为条件1可能会引发一次BGREWRITEAOF，所以在这个检查中，程序会再次确认服务器是否已经在执行持久化操作了）。</li>
<li>检查服务器设置的AOF重写条件是否满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器将开始一次新的BGREWRITEAOF操作（因为条件1和条件2都可能会引起新的持久化操作，所以在这个检查中，我们要再次确认服务器是否已经在执行持久化操作了）。</li>
</ol>
<h3 id="将aof缓冲区中的内容写入aof文件">将AOF缓冲区中的内容写入AOF文件</h3>
<p>如果服务器开启了AOF持久化功能，并且AOF缓冲区里面还有待写入的数据，那么serverCron函数会调用相应的程序，将AOF缓冲区中的内容写入到AOF文件里面。</p>
<h3 id="关闭异步客户端">关闭异步客户端</h3>
<p>服务器会关闭那些输出缓冲区大小超出限制的客户端</p>
<h3 id="增加cronloops计数器的值">增加cronloops计数器的值</h3>
<p>服务器状态的cronloops属性记录了serverCron函数执行的次数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// serverCron函数的运行次数计数器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// serverCron函数每执行一次，这个属性的值就增一。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">cronloops</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>cronloops属性目前在服务器中的唯一作用，就是在复制模块中实现“每执行serverCron函数N次就执行一次指定代码”的功能，方法如以下伪代码所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="n">cronloops</span> <span class="o">%</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="cp">#执行指定代码...
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="初始化服务器">初始化服务器</h2>
<p>一个Redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络连接等。</p>
<h3 id="初始化服务器状态结构">初始化服务器状态结构</h3>
<p>初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。</p>
<p>初始化server变量的工作由redis.c/initServerConfig函数完成，以下是这个函数最开头的一部分代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">initServerConfig</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//设置服务器的运行id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">getRandomHexChars</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">runid</span><span class="p">,</span><span class="n">REDIS_RUN_ID_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//为运行id加上结尾字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">server</span><span class="p">.</span><span class="n">runid</span><span class="p">[</span><span class="n">REDIS_RUN_ID_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//设置默认配置文件路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">server</span><span class="p">.</span><span class="n">configfile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//设置默认服务器频率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">server</span><span class="p">.</span><span class="n">hz</span> <span class="o">=</span> <span class="n">REDIS_DEFAULT_HZ</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//设置服务器的运行架构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">server</span><span class="p">.</span><span class="n">arch_bits</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="o">?</span> <span class="mi">64</span> <span class="o">:</span> <span class="mi">32</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//设置默认服务器端口号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">server</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">REDIS_SERVERPORT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>以下是initServerConfig函数完成的主要工作：</p>
<ul>
<li>设置服务器的运行ID。</li>
<li>设置服务器的默认运行频率。</li>
<li>设置服务器的默认配置文件路径。</li>
<li>设置服务器的运行架构。</li>
<li>设置服务器的默认端口号。</li>
<li>设置服务器的默认RDB持久化条件和AOF持久化条件。</li>
<li>初始化服务器的LRU时钟。</li>
<li>创建命令表。</li>
</ul>
<h3 id="载入配置选项">载入配置选项</h3>
<p>在启动服务器时，用户可以通过给定配置参数或者指定配置文件来修改服务器的默认配置。</p>
<p>服务器在用initServerConfig函数初始化完server变量之后，就会开始载入用户给定的配置参数和配置文件，并根据用户设定的配置，对server变量相关属性的值进行修改。</p>
<h3 id="初始化服务器数据结构">初始化服务器数据结构</h3>
<p>在之前执行initServerConfig函数初始化server状态时，程序只创建了命令表一个数据结构，不过除了命令表之外，服务器状态还包含其他数据结构，比如：</p>
<ul>
<li>server.clients链表，这个链表记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个redisClient结构实例。</li>
<li>server.db数组，数组中包含了服务器的所有数据库。</li>
<li>用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表。</li>
<li>用于执行Lua脚本的Lua环境server.lua。❑用于保存慢查询日志的server.slowlog属性。</li>
</ul>
<p>当初始化服务器进行到这一步，服务器将调用initServer函数，为以上提到的数据结构分配内存，并在有需要时，为这些数据结构设置或者关联初始化值。</p>
<p>服务器到现在才初始化数据结构的原因在于，服务器必须先载入用户指定的配置选项，然后才能正确地对数据结构进行初始化。</p>
<h3 id="还原数据库状态">还原数据库状态</h3>
<p>在完成了对服务器状态server变量的初始化之后，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。</p>
<p>根据服务器是否启用了AOF持久化功能，服务器载入数据时所使用的目标文件会有所不同：</p>
<ul>
<li>如果服务器启用了AOF持久化功能，那么服务器使用AOF文件来还原数据库状态。</li>
<li>相反地，如果服务器没有启用AOF持久化功能，那么服务器使用RDB文件来还原数据库状态。</li>
</ul>
<h3 id="执行事件循环">执行事件循环</h3>
<p>在初始化的最后一步，服务器将打印出以下日志：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">[</span><span class="mi">5244</span><span class="p">]</span> <span class="mi">21</span> <span class="n">Nov</span> <span class="mi">22</span><span class="o">:</span><span class="mi">43</span><span class="o">:</span><span class="mf">49.084</span> <span class="o">*</span> <span class="n">The</span> <span class="n">server</span> <span class="n">is</span> <span class="n">now</span> <span class="n">ready</span> <span class="n">to</span> <span class="n">accept</span> <span class="n">connections</span> <span class="n">on</span> <span class="n">port</span> <span class="mi">6379</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>并开始执行服务器的事件循环（loop）。</p>
<p>至此，服务器的初始化工作圆满完成，服务器现在开始可以接受客户端的连接请求，并处理客户端发来的命令请求了。</p>
<h2 id="重点回顾">重点回顾</h2>
<ul>
<li>一个命令请求从发送到完成主要包括以下步骤：1）客户端将命令请求发送给服务器；2）服务器读取命令请求，并分析出命令参数；3）命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复；4）服务器将命令回复返回给客户端。</li>
<li>serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的SIGTERM信号，管理客户端资源和数据库状态，检查并执行持久化操作等等。</li>
<li>服务器从启动到能够处理客户端的命令请求需要执行以下步骤：1）初始化服务器状态；2）载入服务器配置；3）初始化服务器数据结构；4）还原数据库状态；5）执行事件循环。</li>
</ul>
]]></description></item><item><title>Redis 客户端</title><link>https://xzygis.github.io/posts/introduction-to-redis-client/</link><pubDate>Mon, 12 Dec 2022 23:07:04 +0800</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/introduction-to-redis-client/</guid><description><![CDATA[<p>Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。</p>
<p>通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。</p>
<p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h/redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，其中包括：</p>
<ul>
<li>客户端的套接字描述符。</li>
<li>客户端的名字。</li>
<li>客户端的标志值（flag）。</li>
<li>指向客户端正在使用的数据库的指针，以及该数据库的号码。</li>
<li>客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。</li>
<li>客户端的输入缓冲区和输出缓冲区。</li>
<li>客户端的复制状态信息，以及进行复制所需的数据结构。</li>
<li>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</li>
<li>客户端的事务状态，以及执行WATCH命令时用到的数据结构。</li>
<li>客户端执行发布与订阅功能时用到的数据结构。</li>
<li>客户端的身份验证标志。</li>
<li>客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制（soft limit）的时间。</li>
</ul>
<p>Redis服务器状态结构的clients属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历clients链表来完成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">struct redisServer {
</span></span><span class="line"><span class="cl">    // ...
</span></span><span class="line"><span class="cl">    //一个链表，保存了所有客户端状态
</span></span><span class="line"><span class="cl">    list *clients;
</span></span><span class="line"><span class="cl">    // ...
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="客户端属性">客户端属性</h2>
<p>客户端状态包含的属性可以分为两类：
一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都要用到这些属性。
另外一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务时需要用到的mstate属性，以及执行WATCH命令时需要用到的watched_keys属性等等。</p>
<h3 id="套接字描述符">套接字描述符</h3>
<p>客户端状态的fd属性记录了客户端正在使用的套接字描述符：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">typedef struct redisClient {
</span></span><span class="line"><span class="cl">    // ...
</span></span><span class="line"><span class="cl">    int fd;
</span></span><span class="line"><span class="cl">    // ...
</span></span><span class="line"><span class="cl">} redisClient;
</span></span></code></pre></td></tr></table>
</div>
</div><p>根据客户端类型的不同，fd属性的值可以是-1或者是大于-1的整数：</p>
<ul>
<li>伪客户端（fake client）的fd属性的值为-1：伪客户端处理的命令请求来源于AOF文件或者Lua脚本，而不是网络，所以这种客户端不需要套接字连接，自然也不需要记录套接字描述符。目前Redis服务器会在两个地方用到伪客户端，一个用于载入AOF文件并还原数据库状态，而另一个则用于执行Lua脚本中包含的Redis命令。</li>
<li>普通客户端的fd属性的值为大于-1的整数：普通客户端使用套接字来与服务器进行通信，所以服务器会用fd属性来记录客户端套接字的描述符。因为合法的套接字描述符不能是-1，所以普通客户端的套接字描述符的值必然是大于-1的整数。</li>
</ul>
<h3 id="名字">名字</h3>
<p>在默认情况下，一个连接到服务器的客户端是没有名字的。</p>
<p>使用CLIENT setname命令可以为客户端设置一个名字，让客户端的身份变得更清晰。</p>
<p>客户端的名字记录在客户端状态的name属性里面：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisClient</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">robj</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">redisClient</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="标志">标志</h3>
<p>客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisClient</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">redisClient</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个标志使用一个常量表示：</p>
<ul>
<li>一部分标志记录了客户端的角色：
<ul>
<li>在主从服务器进行复制操作时，主服务器会成为从服务器的客户端，而从服务器也会成为主服务器的客户端。REDIS_MASTER标志表示客户端代表的是一个主服务器，REDIS_SLAVE标志表示客户端代表的是一个从服务器。</li>
<li>REDIS_PRE_PSYNC标志表示客户端代表的是一个版本低于Redis2.8的从服务器，主服务器不能使用PSYNC命令与这个从服务器进行同步。这个标志只能在REDIS_SLAVE标志处于打开状态时使用。❑REDIS_LUA_CLIENT标识表示客户端是专门用于处理Lua脚本里面包含的Redis命令的伪客户端。</li>
</ul>
</li>
<li>而另外一部分标志则记录了客户端目前所处的状态：
<ul>
<li>比如：REDIS_MONITOR、REDIS_UNIX_SOCKET、REDIS_MULTI等</li>
</ul>
</li>
</ul>
<p>以下是一些flags属性的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1">#客户端是一个主服务器</span>
</span></span><span class="line"><span class="cl">REDIS_MASTER
</span></span><span class="line"><span class="cl"><span class="c1">#客户端正在被列表命令阻塞</span>
</span></span><span class="line"><span class="cl">REDIS_BLOCKED
</span></span><span class="line"><span class="cl"><span class="c1">#客户端正在执行事务，但事务的安全性已被破坏</span>
</span></span><span class="line"><span class="cl">REDIS_MULTI <span class="p">|</span> REDIS_DIRTY_CAS
</span></span><span class="line"><span class="cl"><span class="c1">#客户端是一个从服务器，并且版本低于Redis 2.8</span>
</span></span><span class="line"><span class="cl">REDIS_SLAVE <span class="p">|</span> REDIS_PRE_PSYNC
</span></span><span class="line"><span class="cl"><span class="c1">#这是专门用于执行Lua脚本包含的Redis命令的伪客户端</span>
</span></span><span class="line"><span class="cl"><span class="c1">#它强制服务器将当前执行的命令写入AOF文件，并复制给从服务器</span>
</span></span><span class="line"><span class="cl">REDIS_LUA_CLIENT <span class="p">|</span> REDIS_FORCE_AOF<span class="p">|</span> REDIS_FORCE_REPL
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="输入缓冲区">输入缓冲区</h3>
<p>客户端状态的输入缓冲区用于保存客户端发送的命令请求：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisClient</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sds</span> <span class="n">querybuf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">redisClient</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输入缓冲区的大小会根据输入内容动态地缩小或者扩大，但它的最大大小不能超过1GB，否则服务器将关闭这个客户端。</p>
<h3 id="命令与命令参数">命令与命令参数</h3>
<p>在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisClient</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">robj</span> <span class="o">**</span><span class="n">argv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">argc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">redisClient</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中：</p>
<ul>
<li>argv属性是一个数组，数组中的每个项都是一个字符串对象，其中argv[0]是要执行的命令，而之后的其他项则是传给命令的参数。</li>
<li>argc属性则负责记录argv数组的长度。</li>
</ul>
<h3 id="命令的实现函数">命令的实现函数</h3>
<p>当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数。</p>
<p>命令表是一个字典，字典的键是一个SDS结构，保存了命令的名字，字典的值是命令所对应的redisCommand结构，这个结构保存了命令的实现函数、命令的标志、命令应该给定的参数个数、命令的总执行次数和总消耗时长等统计信息。</p>
<p>当程序在命令表中成功找到argv[0]所对应的redisCommand结构时，它会将客户端状态的cmd指针指向这个结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisClient</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">redisCommand</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">redisClient</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>之后，服务器就可以使用cmd属性所指向的redisCommand结构，以及argv、argc属性中保存的命令参数信息，调用命令实现函数，执行客户端指定的命令。</p>
<p>针对命令表的查找操作不区分输入字母的大小写，所以无论argv[0]是&quot;SET&quot;、&ldquo;set&rdquo;、或者&quot;SeT&quot;等等，查找的结果都是相同的。</p>
<h3 id="输出缓冲区">输出缓冲区</h3>
<p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的：</p>
<ul>
<li>固定大小的缓冲区用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等等。</li>
<li>可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。</li>
</ul>
<h3 id="身份验证">身份验证</h3>
<p>客户端状态的authenticated属性用于记录客户端是否通过了身份验证：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisClient</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">authenticated</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">redisClient</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果authenticated的值为0，那么表示客户端未通过身份验证；如果authenticated的值为1，那么表示客户端已经通过了身份验证。</p>
<h3 id="时间">时间</h3>
<p>客户端还有几个和时间有关的属性:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisClient</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">time_t</span> <span class="n">ctime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">time_t</span> <span class="n">lastinteraction</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">time_t</span> <span class="n">obuf_soft_limit_reached_time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">redisClient</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中：</p>
<ul>
<li>ctime属性记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒。</li>
<li>lastinteraction属性记录了客户端与服务器最后一次进行互动（interaction）的时间。lastinteraction属性可以用来计算客户端的空转（idle）时间。</li>
<li>obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制（soft limit）的时间。</li>
</ul>
<h2 id="客户端的创建与关闭">客户端的创建与关闭</h2>
<h3 id="创建普通客户端">创建普通客户端</h3>
<p>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾。</p>
<h3 id="关闭普通客户端">关闭普通客户端</h3>
<p>一个普通客户端可以因为多种原因而被关闭：</p>
<ul>
<li>如果客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭。</li>
<li>如果客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端也会被服务器关闭。</li>
<li>如果客户端成为了CLIENT KILL命令的目标，那么它也会被关闭。</li>
<li>如果用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout选项设置的值时，客户端将被关闭。</li>
<li>如果客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1GB），那么这个客户端会被服务器关闭。</li>
<li>如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭。</li>
</ul>
<p>为了避免客户端的回复过大，占用过多的服务器资源，服务器会时刻检查客户端的输出缓冲区的大小，并在缓冲区的大小超出范围时，执行相应的限制操作。服务器使用两种模式来限制客户端输出缓冲区的大小：</p>
<ul>
<li>硬性限制（hard limit）：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</li>
<li>软性限制（soft limit）：如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间；之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端；相反地，如果输出缓冲区的大小在指定时间之内，不再超出软性限制，那么客户端就不会被关闭，并且obuf_soft_limit_reached_time属性的值也会被清零。</li>
</ul>
<h3 id="lua脚本的伪客户端">Lua脚本的伪客户端</h3>
<p>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">redisClient</span> <span class="o">*</span><span class="n">lua_client</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>lua_client伪客户端在服务器运行的整个生命期中会一直存在，只有服务器被关闭时，这个客户端才会被关闭。</p>
<h3 id="aof文件的伪客户端">AOF文件的伪客户端</h3>
<p>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端。</p>
<h2 id="重点回顾">重点回顾</h2>
<ul>
<li>服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾。</li>
<li>客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。</li>
<li>输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1GB。</li>
<li>命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数。</li>
<li>客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。</li>
<li>输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。</li>
<li>当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求、成为CLIENT KILL命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭。</li>
<li>处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭。</li>
<li>载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。</li>
</ul>
]]></description></item><item><title>Redis AOF持久化</title><link>https://xzygis.github.io/posts/introduction-to-redis-aof-persistence/</link><pubDate>Sat, 10 Dec 2022 14:21:33 +0800</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/introduction-to-redis-aof-persistence/</guid><description><![CDATA[<p>除了<a href="https://chuxing.club/posts/introduction-to-redis-rdb-persistence/"target="_blank" rel="external nofollow noopener noreferrer">RDB持久化功能<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>之外，Redis还提供了AOF（Append Only File）持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p>
<p></p>
<p>服务器在启动时，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态。</p>
<h2 id="aof持久化的实现2">AOF持久化的实现<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></h2>
<p>AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p>
<h3 id="命令追加">命令追加</h3>
<p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// AOF缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sds</span> <span class="n">aof_buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="aof文件的写入与同步">AOF文件的写入与同步</h3>
<p>Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p>
<p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面，这个过程可以用以下伪代码表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">eventLoop</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#处理文件事件，接收命令请求以及发送命令回复</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#处理命令请求时可能会有新内容被追加到 aof_buf缓冲区中</span>
</span></span><span class="line"><span class="cl">        <span class="n">processFileEvents</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#处理时间事件</span>
</span></span><span class="line"><span class="cl">        <span class="n">processTimeEvents</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#考虑是否要将 aof_buf中的内容写入和保存到 AOF文件里面</span>
</span></span><span class="line"><span class="cl">        <span class="n">flushAppendOnlyFile</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>flushAppendOnlyFile</code>函数的行为由服务器配置的<code>appendfsync</code>选项的值来决定，各个不同值产生的行为如下图所示：</p>
<p></p>
<p>如果用户没有主动为appendfsync选项设置值，那么appendfsync选项的默认值为everysec。</p>
<blockquote>
<p><strong>文件的写入和同步</strong></p>
<p>为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。</p>
<p>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。</p>
<p>为此，系统提供了fsync和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p>
</blockquote>
<p>服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性。</p>
<ul>
<li>当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件，所以always的效率是appendfsync选项三个值当中<strong>最慢</strong>的一个，但从安全性来说，always也是最安全的，因为即使出现故障停机，AOF持久化也只会丢失一个事件循环中所产生的命令数据。</li>
<li>当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。<strong>从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据</strong>。</li>
<li>当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。因为处于no模式下的flushAppendOnlyFile调用无须执行同步操作，所以该模式下的AOF文件写入速度总是<strong>最快</strong>的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。</li>
</ul>
<h2 id="aof文件的载入与数据还原">AOF文件的载入与数据还原</h2>
<p>Redis读取AOF文件并还原数据库状态的详细步骤如下：</p>
<ol>
<li>创建一个不带网络连接的伪客户端（fake client）：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。</li>
<li>从AOF文件中分析并读取出一条写命令。</li>
<li>使用伪客户端执行被读出的写命令。</li>
<li>一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</li>
</ol>
<p></p>
<h2 id="aof重写">AOF重写</h2>
<p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。</p>
<p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写（rewrite）功能。通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。</p>
<h3 id="aof文件重写的实现">AOF文件重写的实现</h3>
<p>虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为“AOF文件重写”，但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</p>
<p>整个重写过程可以用以下伪代码表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">aof_rewrite</span><span class="p">(</span><span class="n">new_aof_file_name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#创建新 AOF文件</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span> <span class="o">=</span> <span class="n">create_file</span><span class="p">(</span><span class="n">new_aof_file_name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#遍历数据库</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">db</span> <span class="ow">in</span> <span class="n">redisServer</span><span class="o">.</span><span class="n">db</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#忽略空数据库</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">db</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span> <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#写入SELECT命令，指定数据库号码</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">.</span><span class="n">write_command</span><span class="p">(</span><span class="s2">&#34;SELECT&#34;</span> <span class="o">+</span> <span class="n">db</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#遍历数据库中的所有键</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">db</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">#忽略已过期的键</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">is_expired</span><span class="p">():</span> <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="c1">#根据键的类型对键进行重写</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">String</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">rewrite_string</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">List</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">rewrite_list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">Hash</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">rewrite_hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">Set</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">rewrite_set</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">SortedSet</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">rewrite_sorted_set</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">#如果键带有过期时间，那么过期时间也要被重写</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">have_expire_time</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">                <span class="n">rewrite_expire_time</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#写入完毕，关闭文件</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">rewrite_string</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#使用GET命令获取字符串键的值</span>
</span></span><span class="line"><span class="cl">        <span class="n">value</span> <span class="o">=</span> <span class="n">GET</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#使用SET命令重写字符串键</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">.</span><span class="n">write_command</span><span class="p">(</span><span class="n">SET</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">rewrite_list</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#使用LRANGE命令获取列表键包含的所有元素</span>
</span></span><span class="line"><span class="cl">        <span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">itemN</span> <span class="o">=</span> <span class="n">LRANGE</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#使用RPUSH命令重写列表键</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">.</span><span class="n">write_command</span><span class="p">(</span><span class="n">RPUSH</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">itemN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">rewrite_hash</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#使用HGETALL命令获取哈希键包含的所有键值对</span>
</span></span><span class="line"><span class="cl">        <span class="n">field1</span><span class="p">,</span> <span class="n">value1</span><span class="p">,</span> <span class="n">field2</span><span class="p">,</span> <span class="n">value2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">fieldN</span><span class="p">,</span> <span class="n">valueN</span> <span class="o">=</span> <span class="n">HGETALL</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#使用HMSET命令重写哈希键</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">.</span><span class="n">write_command</span><span class="p">(</span><span class="n">HMSET</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">field1</span><span class="p">,</span> <span class="n">value1</span><span class="p">,</span> <span class="n">field2</span><span class="p">,</span> <span class="n">value2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">fieldN</span><span class="p">,</span> <span class="n">valueN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">rewrite_set</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#使用SMEMBERS命令获取集合键包含的所有元素</span>
</span></span><span class="line"><span class="cl">        <span class="n">elem1</span><span class="p">,</span> <span class="n">elem2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">elemN</span> <span class="o">=</span> <span class="n">SMEMBERS</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#使用SADD命令重写集合键</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">.</span><span class="n">write_command</span><span class="p">(</span><span class="n">SADD</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">elem1</span><span class="p">,</span> <span class="n">elem2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">elemN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">rewrite_sorted_set</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#使用ZRANGE命令获取有序集合键包含的所有元素</span>
</span></span><span class="line"><span class="cl">        <span class="n">member1</span><span class="p">,</span> <span class="n">score1</span><span class="p">,</span> <span class="n">member2</span><span class="p">,</span> <span class="n">score2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">memberN</span><span class="p">,</span> <span class="n">scoreN</span> <span class="o">=</span> <span class="n">ZRANGE</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;WITHSCORES&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#使用ZADD命令重写有序集合键</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">.</span><span class="n">write_command</span><span class="p">(</span><span class="n">ZADD</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">score1</span><span class="p">,</span> <span class="n">member1</span><span class="p">,</span> <span class="n">score2</span><span class="p">,</span> <span class="n">member2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">scoreN</span><span class="p">,</span> <span class="n">memberN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">rewrite_expire_time</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#获取毫秒精度的键过期时间戳</span>
</span></span><span class="line"><span class="cl">        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">get_expire_time_in_unixstamp</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#使用PEXPIREAT命令重写键的过期时间</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">.</span><span class="n">write_command</span><span class="p">(</span><span class="n">PEXPIREAT</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。</p>
<h3 id="aof后台重写">AOF后台重写</h3>
<p>AOF重写程序aof_rewrite函数可以很好地完成创建一个新AOF文件的任务，但是，因为这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞，因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务期将无法处理客户端发来的命令请求。</p>
<p>作为一种辅佐性的维护手段，Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的：</p>
<ul>
<li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li>
<li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li>
</ul>
<p>不过，使用子进程也有一个问题需要解决，因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。</p>
<p>为了解决这种数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p>
<p></p>
<p>在子进程执行AOF重写期间，服务器进程需要执行以下三个工作：</p>
<ol>
<li>执行客户端发来的命令。</li>
<li>将执行后的写命令追加到AOF缓冲区。</li>
<li>将执行后的写命令追加到AOF重写缓冲区。</li>
</ol>
<p>这样一来可以保证：</p>
<ul>
<li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。</li>
<li>从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。</li>
</ul>
<p>当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</p>
<ol>
<li>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</li>
<li>对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li>
</ol>
<p>这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。</p>
<p>在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。</p>
<h2 id="重点回顾">重点回顾</h2>
<ul>
<li>AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。</li>
<li>AOF文件中的所有命令都以Redis命令请求协议的格式保存。</li>
<li>命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件。</li>
<li>appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能有很大的影响。</li>
<li>服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态。</li>
<li>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</li>
<li>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。</li>
<li>在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</li>
</ul>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://chuxing.club/posts/introduction-to-redis-rdb-persistence/"target="_blank" rel="external nofollow noopener noreferrer">Redis RDB持久化<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>《Redis设计与实现》&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></description></item><item><title>Redis RDB持久化</title><link>https://xzygis.github.io/posts/introduction-to-redis-rdb-persistence/</link><pubDate>Fri, 09 Dec 2022 23:22:14 +0800</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/introduction-to-redis-rdb-persistence/</guid><description><![CDATA[<p>Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对，为了方便起见，我们将服务器中的非空数据库以及它们的键值对统称为数据库状态。</p>
<p>因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p>
<p>RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。</p>
<p>RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。 因为RDB文件是保存在硬盘里面的，所以即使Redis服务器进程退出，甚至运行Redis服务器的计算机停机，但只要RDB文件仍然存在，Redis服务器就可以用它来还原数据库状态。</p>
<h2 id="rdb文件的创建与载入1">RDB文件的创建与载入<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></h2>
<p>有两个Redis命令可以用于生成RDB文件，一个是<code>SAVE</code>，另一个是<code>BGSAVE</code>。SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求；BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</p>
<p>创建RDB文件的实际工作由<code>rdb.c/rdbSave</code>函数完成，SAVE命令和BGSAVE命令会以不同的方式调用这个函数，通过以下伪代码可以明显地看出这两个命令之间的区别：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">SAVE</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#创建RDB文件</span>
</span></span><span class="line"><span class="cl">    <span class="n">rdbSave</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">BGSAVE</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#创建子进程</span>
</span></span><span class="line"><span class="cl">    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#子进程负责创建RDB文件</span>
</span></span><span class="line"><span class="cl">        <span class="n">rdbSave</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#完成之后向父进程发送信号</span>
</span></span><span class="line"><span class="cl">        <span class="n">signal_parent</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">elif</span> <span class="n">pid</span> <span class="err">＞</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#父进程继续处理命令请求，并通过轮询等待子进程的信号</span>
</span></span><span class="line"><span class="cl">        <span class="n">handle_request_and_wait_signal</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#处理出错情况</span>
</span></span><span class="line"><span class="cl">        <span class="n">handle_fork_error</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p>
<p>另外值得一提的是，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p>
<ul>
<li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</li>
<li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li>
</ul>
<p></p>
<h3 id="save命令执行时的服务器状态">SAVE命令执行时的服务器状态</h3>
<p>当SAVE命令执行时，Redis服务器会被阻塞，所以当SAVE命令正在执行时，客户端发送的所有命令请求都会被拒绝。只有在服务器执行完SAVE命令、重新开始接受命令请求之后，客户端发送的命令才会被处理。</p>
<h3 id="bgsave命令执行时的服务器状态">BGSAVE命令执行时的服务器状态</h3>
<p>因为BGSAVE命令的保存工作是由子进程执行的，所以在子进程创建RDB文件的过程中，Redis服务器仍然可以继续处理客户端的命令请求，但是，在BGSAVE命令执行期间，服务器处理SAVE、BGSAVE、BGREWRITEAOF三个命令的方式会和平时有所不同。</p>
<ul>
<li>首先，在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。</li>
<li>其次，在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件。</li>
<li>最后，BGREWRITEAOF和BGSAVE两个命令不能同时执行：
<ul>
<li>如果BGSAVE命令正在执行，那么客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行。</li>
<li>如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。</li>
</ul>
</li>
</ul>
<p>因为BGREWRITEAOF和BGSAVE两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作，这怎么想都不会是一个好主意。</p>
<h3 id="rdb文件载入时的服务器状态">RDB文件载入时的服务器状态</h3>
<p>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p>
<h2 id="自动间隔性保存">自动间隔性保存</h2>
<p>因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。</p>
<p>举个例子，如果我们向服务器提供以下配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">save 900 1
</span></span><span class="line"><span class="cl">save 300 10
</span></span><span class="line"><span class="cl">save 60 10000
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行：</p>
<ul>
<li>服务器在900秒之内，对数据库进行了至少1次修改。</li>
<li>服务器在300秒之内，对数据库进行了至少10次修改。</li>
<li>服务器在60秒之内，对数据库进行了至少10000次修改。</li>
</ul>
<h3 id="设置保存条件">设置保存条件</h3>
<p>当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件。服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//记录了保存条件的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">saveparam</span> <span class="o">*</span><span class="n">saveparams</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="dirty计数器和lastsave属性">dirty计数器和lastsave属性</h3>
<p>除了saveparams数组之外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性：</p>
<ul>
<li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。</li>
<li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//修改计数器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//上一次执行保存的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">time_t</span> <span class="n">lastsave</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="检查保存条件是否满足">检查保存条件是否满足</h3>
<p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">serverCron</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#遍历所有保存条件</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">saveparam</span> <span class="ow">in</span> <span class="n">server</span><span class="o">.</span><span class="n">saveparams</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#计算距离上次执行保存操作有多少秒</span>
</span></span><span class="line"><span class="cl">        <span class="n">save_interval</span> <span class="o">=</span> <span class="n">unixtime_now</span><span class="p">()</span><span class="o">-</span><span class="n">server</span><span class="o">.</span><span class="n">lastsave</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#如果数据库状态的修改次数超过条件所设置的次数</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#并且距离上次保存的时间超过条件所设置的时间</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#那么执行保存操作</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">server</span><span class="o">.</span><span class="n">dirty</span> <span class="err">＞</span><span class="o">=</span> <span class="n">saveparam</span><span class="o">.</span><span class="n">changes</span> <span class="ow">and</span> \
</span></span><span class="line"><span class="cl">           <span class="n">save_interval</span> <span class="err">＞</span> <span class="n">saveparam</span><span class="o">.</span><span class="n">seconds</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">BGSAVE</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>程序会遍历并检查saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令。</p>
<h2 id="rdb文件结构">RDB文件结构</h2>
<p>一个完整的RDB文件包含以下几个部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="p">|</span> REDIS <span class="p">|</span> db_version <span class="p">|</span> databases <span class="p">|</span> EOF <span class="p">|</span> check_sum <span class="p">|</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中：</p>
<ul>
<li>RDB文件的最开头是REDIS部分，这个部分的长度为5字节，保存着“REDIS”五个字符。通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否RDB文件。</li>
<li>db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如&quot;0006&quot;就代表RDB文件的版本为第六版</li>
<li>databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据。</li>
<li>EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。</li>
<li>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。</li>
</ul>
<h3 id="databases部分">databases部分</h3>
<p>一个RDB文件的databases部分可以保存任意多个非空数据库。每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="p">|</span> SELECTDB <span class="p">|</span> db_number <span class="p">|</span> key_value_pairs <span class="p">|</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="key_value_pairs部分">key_value_pairs部分</h3>
<p>RDB文件中的每个key_value_pairs部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="p">|</span> TYPE <span class="p">|</span> key <span class="p">|</span> value <span class="p">|</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>TYPE记录了value的类型，长度为1字节，每个TYPE常量都代表了一种对象类型或者底层编码，当服务器读入RDB文件中的键值对数据时，程序会根据TYPE的值来决定如何读入和解释value的数据。Type的值可以是以下常量的其中一个：</p>
<ul>
<li>REDIS_RDB_TYPE_STRING</li>
<li>REDIS_RDB_TYPE_LIST</li>
<li>REDIS_RDB_TYPE_SET</li>
<li>REDIS_RDB_TYPE_ZSET</li>
<li>REDIS_RDB_TYPE_HASH</li>
<li>REDIS_RDB_TYPE_LIST_ZIPLIST</li>
<li>REDIS_RDB_TYPE_SET_INTSET</li>
<li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li>
<li>REDIS_RDB_TYPE_HASH_ZIPLIST</li>
</ul>
<p>带有过期时间的键值对在RDB文件中的结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="p">|</span> EXPIRETIME_MS <span class="p">|</span> ms <span class="p">|</span> TYPE <span class="p">|</span> key <span class="p">|</span> value <span class="p">|</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，</p>
<ul>
<li>EXPIRETIME_MS常量的长度为1字节，它告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间。</li>
<li>ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间。</li>
</ul>
<h3 id="value的编码">value的编码</h3>
<p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构、长度也会有所不同。</p>
<h2 id="分析rdb文件">分析RDB文件</h2>
<p>我们可以使用od命令来分析Redis服务器产生的RDB文件，该命令可以用给定的格式转存（dump）并打印输入文件。</p>
<h2 id="重点回顾">重点回顾</h2>
<ul>
<li>RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。</li>
<li>SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。</li>
<li>BGSAVE令由子进程执行保存操作，所以该命令不会阻塞服务器。</li>
<li>服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。</li>
<li>RDB文件是一个经过压缩的二进制文件，由多个部分组成。</li>
<li>对于不同类型的键值对，RDB文件会使用不同的方式来保存它们。</li>
</ul>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>《Redis设计与实现》&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></description></item><item><title>Redis 服务器数据库实现</title><link>https://xzygis.github.io/posts/redis-server-database-implementation-introduction/</link><pubDate>Thu, 08 Dec 2022 23:39:55 +0800</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/redis-server-database-implementation-introduction/</guid><description><![CDATA[<h2 id="服务器中的数据库1">服务器中的数据库<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></h2>
<p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 一个数组，保存着服务器中的所有数据库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">redisDb</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 服务器的数据库数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">dbnum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16，所以Redis服务器默认会创建16个数据库。</p>
<p></p>
<h2 id="切换数据库">切换数据库</h2>
<p>默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。</p>
<p>在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">typedef struct redisClient {
</span></span><span class="line"><span class="cl">    // ...
</span></span><span class="line"><span class="cl">    // 记录客户端当前正在使用的数据库
</span></span><span class="line"><span class="cl">    redisDb *db;
</span></span><span class="line"><span class="cl">    // ...
</span></span><span class="line"><span class="cl">} redisClient;
</span></span></code></pre></td></tr></table>
</div>
</div><p>redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。</p>
<h2 id="数据库键空间">数据库键空间</h2>
<p>Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisDb</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 数据库键空间，保存着数据库中的所有键值对
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dict</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">redisDb</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>键空间和用户所见的数据库是直接对应的：</p>
<ul>
<li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li>
<li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li>
</ul>
<p>因为数据库的键空间是一个字典，所以所有针对数据库的操作，比如添加一个键值对到数据库，或者从数据库中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间字典进行操作来实现的。</p>
<h3 id="读写键空间时的维护操作">读写键空间时的维护操作</h3>
<p>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，其中包括：</p>
<ul>
<li>在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li>
<li>在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。</li>
<li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作，本章稍后对过期键的讨论会详细说明这一点。</li>
<li>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过。</li>
<li>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</li>
<li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知，本章稍后讨论数据库通知功能的实现时会详细说明这一点。</li>
</ul>
<h2 id="设置键的生存时间或过期时间">设置键的生存时间或过期时间</h2>
<p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。</p>
<h3 id="设置过期时间">设置过期时间</h3>
<p>Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）：</p>
<ul>
<li>EXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl秒。</li>
<li>PEXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl毫秒。</li>
<li>EXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。</li>
<li>PEXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。</li>
</ul>
<h3 id="保存过期时间">保存过期时间</h3>
<p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p>
<ul>
<li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。</li>
<li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li>
</ul>
<h3 id="移除过期时间">移除过期时间</h3>
<p>PERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p>
<h3 id="过期键的判定">过期键的判定</h3>
<p>通过过期字典，程序可以用以下步骤检查一个给定键是否过期：</p>
<ol>
<li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。</li>
<li>检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。</li>
</ol>
<h2 id="过期键删除策略">过期键删除策略</h2>
<p>三种不同的删除策略：</p>
<ul>
<li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</li>
<li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</li>
<li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>
</ul>
<h3 id="定时删除">定时删除</h3>
<p>定时删除策略对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。 另一方面，定时删除策略的缺点是，它对CPU时间是最不友好的。</p>
<p>除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O（N）——并不能高效地处理大量时间事件。</p>
<h3 id="惰性删除">惰性删除</h3>
<p>惰性删除策略对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。</p>
<p>惰性删除策略的缺点是，它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。</p>
<p>在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏——无用的垃圾数据占用了大量的内存。</p>
<h3 id="定期删除">定期删除</h3>
<p>从上面对定时删除和惰性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷：</p>
<ul>
<li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li>
<li>惰性删除浪费太多内存，有内存泄漏的危险。</li>
</ul>
<p>定期删除策略是前两种策略的一种整合和折中：</p>
<ul>
<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
<li>除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。</li>
</ul>
<p>定期删除策略的难点是确定删除操作执行的时长和频率：</p>
<ul>
<li>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。</li>
<li>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。</li>
</ul>
<p>因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</p>
<h2 id="redis的过期键删除策略">Redis的过期键删除策略</h2>
<p>Redis服务器实际使用的是<strong>惰性删除</strong>和<strong>定期删除</strong>两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p>
<h3 id="惰性删除策略的实现">惰性删除策略的实现</h3>
<p>过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：</p>
<ul>
<li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除。</li>
<li>如果输入键未过期，那么expireIfNeeded函数不做动作。</li>
</ul>
<h3 id="定期删除策略的实现">定期删除策略的实现</h3>
<p>过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p>
<p>整个过程可以用伪代码描述如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#默认每次检查的数据库数量
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">DEFAULT_DB_NUMBERS</span> <span class="o">=</span> <span class="mi">16</span>
</span></span><span class="line"><span class="cl"><span class="cp">#默认每个数据库检查的键数量
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">DEFAULT_KEY_NUMBERS</span> <span class="o">=</span> <span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="cp">#全局变量，记录检查进度
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">current_db</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">def</span> <span class="nf">activeExpireCycle</span><span class="p">()</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="cp">#初始化要检查的数据库数量
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp">#如果服务器的数据库数量比 DEFAULT_DB_NUMBERS要小
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp">#那么以服务器的数据库数量为准
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="k">if</span> <span class="n">server</span><span class="p">.</span><span class="n">dbnum</span> <span class="err">＜</span> <span class="nl">DEFAULT_DB_NUMBERS</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">db_numbers</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">dbnum</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">db_numbers</span> <span class="o">=</span> <span class="n">DEFAULT_DB_NUMBERS</span>
</span></span><span class="line"><span class="cl">    <span class="cp">#遍历各个数据库
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">db_numbers</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#如果current_db的值等于服务器的数据库数量
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp">#这表示检查程序已经遍历了服务器的所有数据库一次
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp">#将current_db重置为0，开始新的一轮遍历
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="k">if</span> <span class="n">current_db</span> <span class="o">==</span> <span class="n">server</span><span class="p">.</span><span class="nl">dbnum</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">current_db</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#获取当前要处理的数据库
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="n">redisDb</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">db</span><span class="p">[</span><span class="n">current_db</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#将数据库索引增1，指向下一个要处理的数据库
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="n">current_db</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#检查数据库键
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="k">for</span> <span class="n">j</span> <span class="n">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">DEFAULT_KEY_NUMBERS</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">            <span class="cp">#如果数据库中没有一个键带有过期时间，那么跳过这个数据库
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>            <span class="k">if</span> <span class="n">redisDb</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span> <span class="k">break</span>
</span></span><span class="line"><span class="cl">            <span class="cp">#随机获取一个带有过期时间的键
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>            <span class="n">key_with_ttl</span> <span class="o">=</span> <span class="n">redisDb</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="nf">get_random_key</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="cp">#检查键是否过期，如果过期就删除它
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>            <span class="k">if</span> <span class="nf">is_expired</span><span class="p">(</span><span class="n">key_with_ttl</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">                <span class="nf">delete_key</span><span class="p">(</span><span class="n">key_with_ttl</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="cp">#已达到时间上限，停止处理
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>            <span class="k">if</span> <span class="nf">reach_time_limit</span><span class="p">()</span><span class="o">:</span> <span class="k">return</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>activeExpireCycle函数的工作模式可以总结如下：</p>
<ul>
<li>函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。</li>
<li>全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。</li>
<li>随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。</li>
</ul>
<h2 id="aofrdb和复制功能对过期键的处理">AOF、RDB和复制功能对过期键的处理</h2>
<h3 id="生成rdb文件">生成RDB文件</h3>
<p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</p>
<h3 id="载入rdb文件">载入RDB文件</h3>
<p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p>
<ul>
<li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li>
<li>如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。</li>
</ul>
<h3 id="aof文件写入">AOF文件写入</h3>
<p>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。</p>
<h3 id="aof重写">AOF重写</h3>
<p>和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p>
<h3 id="复制">复制</h3>
<p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p>
<ul>
<li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li>
<li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。❑从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li>
</ul>
<p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。</p>
<h2 id="重点回顾">重点回顾</h2>
<ul>
<li>Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则由redisServer.dbnum属性保存。</li>
<li>客户端通过修改目标数据库指针，让它指向redisServer.db数组中的不同元素来切换不同的数据库。</li>
<li>数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。</li>
<li>因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。</li>
<li>数据库的键总是一个字符串对象，而值则可以是任意一种Redis对象类型，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符串键、哈希表键、集合键、列表键和有序集合键。❑expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳。</li>
<li>Redis使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。</li>
<li>执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。</li>
<li>执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。</li>
<li>当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。</li>
<li>当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键。</li>
<li>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li>
<li>当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</li>
</ul>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>《Redis设计与实现》&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></description></item><item><title>Redis 对象</title><link>https://xzygis.github.io/posts/introduction-to-redis-object/</link><pubDate>Wed, 07 Dec 2022 20:10:37 +0800</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/introduction-to-redis-object/</guid><description><![CDATA[<p>在 <a href="https://chuxing.club/posts/introduction-to-the-underlying-data-structure-of-redis/"target="_blank" rel="external nofollow noopener noreferrer">Redis底层数据结构介绍<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> 中我们介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。</p>
<p>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</p>
<p>除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。</p>
<p>最后，Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。</p>
<h2 id="对象的类型与编码2">对象的类型与编码<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></h2>
<p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。</p>
<p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisObject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">type</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//编码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">encoding</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//指向底层实现数据结构的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">robj</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="类型">类型</h3>
<p>对象的type属性记录了对象的类型，这个属性的下表列出的常量的其中一个。</p>
<p></p>
<p>对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种，因此：</p>
<ul>
<li>当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象”；</li>
<li>当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”。</li>
</ul>
<h3 id="编码和底层实现">编码和底层实现</h3>
<p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现。</p>
<p></p>
<p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。</p>
<h2 id="字符串对象">字符串对象</h2>
<p>字符串对象的编码可以是int、raw或者embstr。</p>
<ul>
<li>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int。</li>
<li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</li>
<li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</li>
</ul>
<p>embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象，但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构。</p>
<p></p>
<p>embstr编码的字符串对象在执行命令时，产生的效果和raw编码的字符串对象执行命令时产生的效果是相同的，但使用embstr编码的字符串对象来保存短字符串值有以下好处：</p>
<ul>
<li>embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。</li>
<li>释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</li>
<li>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。</li>
</ul>
<h3 id="编码转换">编码转换</h3>
<p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。对于int编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw。</p>
<p>因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序（只有int编码的字符串对象和raw编码的字符串对象有这些程序），所以embstr编码的字符串对象实际上是只读的。当我们对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。</p>
<h2 id="列表对象">列表对象</h2>
<p>列表对象的编码可以是ziplist或者linkedlist。</p>
<ul>
<li>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。</li>
<li>linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</li>
</ul>
<h3 id="编码转换-1">编码转换</h3>
<p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于64字节；</li>
<li>列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。</li>
</ul>
<h2 id="哈希对象">哈希对象</h2>
<p>哈希对象的编码可以是ziplist或者hashtable。</p>
<ul>
<li>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。</li>
<li>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：
<ul>
<li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</li>
</ul>
</li>
</ul>
<h3 id="编码转换-2">编码转换</h3>
<p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li>
<li>哈希对象保存的键值对数量小于512个；不能满足这两个条件的哈希对象需要使用hashtable编码。</li>
</ul>
<blockquote>
<p>这两个条件的上限值是可以修改的，具体请看配置文件中关于hash-max-ziplist-value选项和hash-max-ziplist-entries选项的说明。</p>
</blockquote>
<h2 id="集合对象">集合对象</h2>
<p>集合对象的编码可以是intset或者hashtable。</p>
<ul>
<li>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</li>
<li>hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。</li>
</ul>
<h3 id="编码转换-3">编码转换</h3>
<p>当集合对象可以同时满足以下两个条件时，对象使用intset编码：</p>
<ul>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过512个。</li>
</ul>
<p>不能满足这两个条件的集合对象需要使用hashtable编码。</p>
<h2 id="有序集合对象">有序集合对象</h2>
<p>有序集合的编码可以是ziplist或者skiplist。</p>
<ul>
<li>ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。</li>
<li>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表。</li>
</ul>
<p>zset结构定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zset</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">zskiplist</span> <span class="o">*</span><span class="n">zsl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">dict</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">zset</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK、ZRANGE等命令就是基于跳跃表API来实现的。</p>
<p>除此之外，zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，程序可以用O（1）复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性。</p>
<p>有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。值得一提的是，虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，也不会因此而浪费额外的内存。</p>
<blockquote>
<p>为什么有序集合需要同时使用跳跃表和字典来实现？
在理论上，有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现，但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低。举个例子，如果我们只使用字典来实现有序集合，那么虽然以O（1）复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行范围型操作——比如ZRANK、ZRANGE等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少O（NlogN）时间复杂度，以及额外的O（N）内存空间（因为要创建一个数组来保存排序后的元素）。
另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O（1）上升为O（logN）。因为以上原因，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis选择了同时使用字典和跳跃表两种数据结构来实现有序集合。</p>
</blockquote>
<h3 id="编码转换-4">编码转换</h3>
<p>当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：</p>
<ul>
<li>有序集合保存的元素数量小于128个；</li>
<li>有序集合保存的所有元素成员的长度都小于64字节；</li>
</ul>
<p>不能满足以上两个条件的有序集合对象将使用skiplist编码。</p>
<h2 id="类型检查与多态">类型检查与多态</h2>
<p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p>
<h2 id="内存回收">内存回收</h2>
<p>因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p>
<p>每个对象的引用计数信息由redisObject结构的refcount属性记录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisObject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//引用计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">refcount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">robj</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>
<ul>
<li>在创建一个新对象时，引用计数的值会被初始化为1；</li>
<li>当对象被一个新程序使用时，它的引用计数值会被增一；</li>
<li>当对象不再被一个程序使用时，它的引用计数值会被减一；</li>
<li>当对象的引用计数值变为0时，对象所占用的内存会被释放。</li>
</ul>
<h2 id="对象共享">对象共享</h2>
<p>Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。</p>
<p>在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：</p>
<ul>
<li>将数据库键的值指针指向一个现有的值对象；</li>
<li>将被共享的值对象的引用计数增一。</li>
</ul>
<p>共享对象机制对于节约内存非常有帮助，数据库中保存的相同值对象越多，对象共享机制就能节约越多的内存。</p>
<p>尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。</p>
<h2 id="对象的空转时长">对象的空转时长</h2>
<p>除了前面介绍过的type、encoding、ptr和refcount四个属性之外，redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisObject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">lru</span><span class="p">:</span><span class="mi">22</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">robj</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p>
<h2 id="重点回顾">重点回顾</h2>
<ul>
<li>Redis数据库中的每个键值对的键和值都是一个对象。</li>
<li>Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。</li>
<li>Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。</li>
<li>Redis会共享值为0到9999的字符串对象。</li>
<li>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。</li>
</ul>
<p>参考来源：</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://chuxing.club/posts/introduction-to-the-underlying-data-structure-of-redis/"target="_blank" rel="external nofollow noopener noreferrer">https://chuxing.club/posts/introduction-to-the-underlying-data-structure-of-redis/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>《Redis设计与实现》&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></description></item><item><title>Hugo 快速入门</title><link>https://xzygis.github.io/posts/hugo-quick-start/</link><pubDate>Sat, 03 Dec 2022 19:21:25 +0800</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/hugo-quick-start/</guid><description><![CDATA[<p>Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。</p>
<h2 id="intall">Intall</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">go install github.com/gohugoio/hugo@latest
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="quick-start">Quick Start</h2>
<blockquote>
<p><a href="https://gohugo.io/getting-started/quick-start/"target="_blank" rel="external nofollow noopener noreferrer">https://gohugo.io/getting-started/quick-start/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</blockquote>
<p>运行以下命令创建一个使用<code>Ananke</code>主题的网站：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">hugo new site quickstart
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> quickstart
</span></span><span class="line"><span class="cl">git init
</span></span><span class="line"><span class="cl">git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;theme = &#39;ananke&#39;&#34;</span> &gt;&gt; config.toml
</span></span><span class="line"><span class="cl">hugo server
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="add-content">Add Content</h2>
<p>给网站增加新的网页：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">hugo new posts/my-first-post.md
</span></span></code></pre></td></tr></table>
</div>
</div><p>Hugo在<code>content/posts</code>目录创建了<code>my-first-post.md</code>文件，文件内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">---
</span></span><span class="line"><span class="cl">title: <span class="s2">&#34;My First Post&#34;</span>
</span></span><span class="line"><span class="cl">date: 2022-11-20T09:03:20-08:00
</span></span><span class="line"><span class="cl">draft: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">---
</span></span></code></pre></td></tr></table>
</div>
</div><p>修改并保存文件后启动Hugo服务器可以预览网站，可以使用以下的任一命令以包含draft内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">hugo server --buildDrafts
</span></span><span class="line"><span class="cl">hugo server -D
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="configure-the-site">Configure the site</h2>
<p>可以通过根目录的<code>config.toml</code>文件配置网站相关信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nv">baseURL</span> <span class="o">=</span> <span class="s1">&#39;http://example.org/&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nv">languageCode</span> <span class="o">=</span> <span class="s1">&#39;en-us&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nv">title</span> <span class="o">=</span> <span class="s1">&#39;My New Hugo Site&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nv">theme</span> <span class="o">=</span> <span class="s1">&#39;ananke&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="publish-the-site">Publish the site</h2>
<p>生成站点的静态文件，文件将生成到根目录下的<code>public</code>目录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">hugo
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="host-on-github">Host on GitHub</h2>
<blockquote>
<p><a href="https://gohugo.io/hosting-and-deployment/hosting-on-github/"target="_blank" rel="external nofollow noopener noreferrer">https://gohugo.io/hosting-and-deployment/hosting-on-github/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</blockquote>
<ol>
<li>创建名为<code>&lt;USERNAME&gt;.github.io</code> 或 <code>&lt;ORGANIZATION&gt;.github.io</code>的GitHub仓库</li>
<li>在仓库中新增文件<code>.github/workflows/gh-pages.yml</code>并填写以下内容：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">github pages</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">push</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">main </span><span class="w"> </span><span class="c"># Set a branch that will trigger a deployment</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pull_request</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">jobs</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">deploy</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l">ubuntu-22.04</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">steps</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/checkout@v3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">submodules</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">  </span><span class="c"># Fetch Hugo themes (true OR recursive)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">fetch-depth</span><span class="p">:</span><span class="w"> </span><span class="m">0</span><span class="w">    </span><span class="c"># Fetch all history for .GitInfo and .Lastmod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Setup Hugo</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">peaceiris/actions-hugo@v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">hugo-version</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;latest&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="c"># extended: true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Build</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l">hugo --minify</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Deploy</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">peaceiris/actions-gh-pages@v3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">if</span><span class="p">:</span><span class="w"> </span><span class="l">github.ref == &#39;refs/heads/main&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">github_token</span><span class="p">:</span><span class="w"> </span><span class="l">${{ secrets.GITHUB_TOKEN }}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">publish_dir</span><span class="p">:</span><span class="w"> </span><span class="l">./public</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>把<code>config.toml</code>中的<code>baseURL</code>修改为<code>https://&lt;USERNAME&gt;.github.io</code>。</p>
<p>Ref：</p>
<ol>
<li><a href="https://github.com/gohugoio/hugo"target="_blank" rel="external nofollow noopener noreferrer">https://github.com/gohugoio/hugo<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://www.xianmin.org/post/2022/07-familiar-one-keybinding-style/"target="_blank" rel="external nofollow noopener noreferrer">https://www.xianmin.org/post/2022/07-familiar-one-keybinding-style/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ol>
]]></description></item><item><title>Redis 底层数据结构</title><link>https://xzygis.github.io/posts/introduction-to-the-underlying-data-structure-of-redis/</link><pubDate>Wed, 30 Nov 2022 22:03:21 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/introduction-to-the-underlying-data-structure-of-redis/</guid><description><![CDATA[<h2 id="简单动态字符串1">简单动态字符串<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></h2>
<p>每个sds.h/sdshdr结构表示一个SDS值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">sdshdr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//记录buf数组中已使用字节的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//等于SDS所保存字符串的长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//记录buf数组中未使用字节的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">free</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//字节数组，用于保存字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="sds与c字符串的区别">SDS与C字符串的区别</h3>
<ul>
<li>常数时间复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串带来的内存重分配次数（空间预分配、惰性空间释放）</li>
<li>二进制安全</li>
<li>兼容部分C字符串函数</li>
</ul>
<h2 id="链表">链表</h2>
<p>当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。</p>
<p>每个链表节点使用一个adlist.h/listNode结构来表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">listNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 前置节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 后置节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//节点的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">listNode</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。
每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。
因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。</p>
<p>虽然仅仅使用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表的话，操作起来会更方便：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">list</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">表头节点</span>
</span></span><span class="line"><span class="cl">    <span class="n">listNode</span> <span class="o">*</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">表尾节点</span>
</span></span><span class="line"><span class="cl">    <span class="n">listNode</span> <span class="o">*</span> <span class="n">tail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">链表所包含的节点数量</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">节点值复制函数</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">dup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">节点值释放函数</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">节点值对比函数</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">list</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。</p>
<h2 id="字典">字典</h2>
<p>字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。</p>
<p>当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。</p>
<p>Redis字典所使用的哈希表由dict.h/dictht结构定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictht</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//哈希表数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dictEntry</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//哈希表大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//哈希表大小掩码，用于计算索引值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//总是等于size-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sizemask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//该哈希表已有节点的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">dictht</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。size属性记录了哈希表的大小，也即是table数组的大小，而used属性则记录了哈希表目前已有节点（键值对）的数量。sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面。</p>
<p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictEntry</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//键
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">union</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">uint64_tu64</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">int64_ts64</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//指向下个哈希表节点，形成链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">dictEntry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">dictEntry</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。</p>
<p>Redis中的字典由dict.h/dict结构表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dict</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//类型特定函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dictType</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//私有数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//哈希表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dictht</span> <span class="n">ht</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// rehash索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//当rehash不在进行时，值为-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">in</span> <span class="n">trehashidx</span><span class="p">;</span> <span class="cm">/* rehashing not in progress if rehashidx == -1 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">dict</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：</p>
<ul>
<li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</li>
<li>而privdata属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictType</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//计算哈希值的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hashFunction</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//复制键的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">keyDup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//复制值的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">valDup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//对比键的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">keyCompare</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//销毁键的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">keyDestructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//销毁值的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">valDestructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">dictType</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。除了ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。</p>
<p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>Redis计算哈希值和索引值的方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#使用字典设置的哈希函数，计算键key的哈希值
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">hash</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-</span><span class="err">＞</span><span class="n">type</span><span class="o">-</span><span class="err">＞</span><span class="nf">hashFunction</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#使用哈希表的sizemask属性和哈希值，计算出索引值
</span></span></span><span class="line"><span class="cl"><span class="cp">#根据情况不同，ht[x]可以是ht[0]或者ht[1]
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span> <span class="n">dict</span><span class="o">-</span><span class="err">＞</span><span class="n">ht</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">sizemask</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Redis的哈希表使用链地址法（separate chaining）来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。</p>
<h3 id="rehash">rehash</h3>
<p>根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。</p>
<p>为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1]，而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]。</p>
<p>哈希表渐进式rehash的详细步骤：</p>
<ul>
<li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li>
<li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li>
<li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</li>
<li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。</li>
</ul>
<p>因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。例如，要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht[1]里面进行查找，诸如此类。</p>
<p>另外，在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表。</p>
<h2 id="跳跃表">跳跃表</h2>
<p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p>
<p>跳跃表节点的实现由redis.h/zskiplistNode结构定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//层
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">zskiplistLevel</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//前进指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">forward</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//跨度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">span</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="n">level</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//后退指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">backward</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//分值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//成员对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">robj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">zskiplistNode</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。</p>
<p>跨度（span）实际上是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p>
<p>节点的后退指针（backward属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p>
<p>zskiplist结构的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplist</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//表头节点和表尾节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">structz</span> <span class="n">skiplistNode</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//表中节点的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//表中层数最大的节点的层数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">zskiplist</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="整数集合">整数集合</h2>
<p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p>
<p>每个intset.h/intset结构表示一个整数集合：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">intset</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//编码方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint32_t</span> <span class="n">encoding</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//集合包含的元素数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint32_t</span> <span class="n">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//保存元素的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int8_t</span> <span class="n">contents</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">intset</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。</p>
<p>因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素：</p>
<p>要让一个数组可以同时保存int16_t、int32_t、int64_t三种类型的值，最简单的做法就是直接使用int64_t类型的数组作为整数集合的底层实现。不过这样一来，即使添加到整数集合里面的都是int16_t类型或者int32_t类型的值，数组都需要使用int64_t类型的空间去保存它们，从而出现浪费内存的情况。而整数集合现在的做法既可以让集合能同时保存三种不同类型的值，又可以确保升级操作只会在有需要的时候进行，这可以尽量节省内存。</p>
<p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p>
<h2 id="压缩列表">压缩列表</h2>
<p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p>
<p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p>
<p>ziplist的组成部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="p">|</span> zlbytes <span class="p">|</span> ztail <span class="p">|</span> zlen <span class="p">|</span> entry1 <span class="p">|</span> entry2 <span class="p">|</span> ... <span class="p">|</span> entryN <span class="p">|</span> zlend <span class="p">|</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="p">|</span> previous_entry_length <span class="p">|</span> encoding <span class="p">|</span> content <span class="p">|</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。</p>
<p>尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：</p>
<ul>
<li>首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；-</li>
<li>其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的；</li>
</ul>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>《Redis设计与实现》&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></description></item><item><title>Tair:分布式键/值存储系统</title><link>https://xzygis.github.io/posts/tair-a-distributed-key-value-storage-system-developed-by-alibaba-group/</link><pubDate>Sun, 27 Nov 2022 23:11:28 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/tair-a-distributed-key-value-storage-system-developed-by-alibaba-group/</guid><description><![CDATA[<h2 id="产品概览">产品概览</h2>
<p>Tair 是快速访问内存 (MDB)/持久性 (LDB) 存储服务。</p>
<p>Tair采用高性能、高可用的分布式集群架构，可以满足企业对读写性能和可扩展容量的高要求。</p>
<h2 id="系统架构">系统架构</h2>
<p>Tair 集群具有三个必要的模块：ConfigServer、DataServer 和客户端。</p>
<p></p>
<p>通常，一个 Tair 集群包括两个 ConfigServer 和多个 DataServer。 两个 ConfigServer 充当主服务器和备用服务器。 DataServer 和 ConfigServer 之间的心跳检查用于检查集群中活跃的和可用的 DataServer，以建立集群中数据的分布（比较表）。 DataServers 按照 ConfigServer 的指示存储、复制和迁移数据。当客户端启动时，它从 ConfigServer 获取数据分布信息。客户端根据这些数据分布信息，与对应的DataServer进行交互，执行用户的请求。</p>
<p>在架构上，ConfigServer 的作用类似于传统应用系统中的中心节点。整个集群服务依赖于ConfigServer。 事实上，Tair 的 ConfigServers 是非常轻量级的。当一个工作的 ConfigServer 遇到停机时间时，另一个 ConfigServer 会在几秒钟内自动接管。 即使两个 ConfigServer 同时停机，只要 DataServer 没有变化，Tair 也可以正常运行。 用户只需要将应用程序连接到 ConfigServers，不需要知道内部节点的详细信息。</p>
<h3 id="configserver">ConfigServer</h3>
<p>两个 ConfigServers 作为主服务器和备用服务器。</p>
<p>集群的实时和可用 DataServer 节点信息是使用 ConfigServer 和 DataServer 之间的心跳检查确定的。</p>
<p>ConfigServer根据DataServer节点信息构建数据分布表，展示数据在集群中的分布情况。</p>
<p>ConfigServer 提供数据分发表查询服务。</p>
<p>ConfigServer 调度数据服务器之间的数据迁移和复制。</p>
<h3 id="dataservers-数据服务器">DataServers 数据服务器</h3>
<p>DataServers 提供存储引擎。</p>
<p>DataServers 接收客户端发起的操作，例如 put/get/remove。</p>
<p>DataServers 迁移和复制数据。</p>
<p>DataServers 提供访问统计信息。</p>
<h3 id="clients-客户端">Clients 客户端</h3>
<p>客户端提供用于访问 Tair 集群的 API。</p>
<p>客户端更新和缓存数据分发表。</p>
<p>客户端提供LocalCache，防止过热的数据访问影响Tair集群服务。</p>
<p>客户端控制流量。</p>
<h2 id="产品特点">产品特点</h2>
<h3 id="分布式架构">分布式架构</h3>
<p>分布式集群架构用于提供自动灾难恢复和故障转移。</p>
<p>支持负载均衡，数据分布均匀。</p>
<p>系统存储空间和吞吐量性能可以弹性伸缩，解决数据量和QPS性能限制。</p>
<p>功能齐全且用户友好的访问</p>
<p>数据结构丰富。 支持单级键值结构和二级索引结构。</p>
<p>支持各种用途。 还支持计数器模式。</p>
<p>支持数据过期和版本控制。</p>
<h3 id="version-支持">Version 支持</h3>
<p>Tair 中的每个数据都包含版本号，版本号在每次更新后都会递增。这个特性有助于防止由于数据的并发更新导致的问题。</p>
<p>比如，系统有一个 value 为 “a,b,c”，A 和 B 同时 get 到这个 value。A 执行操作，在后面添加一个 d，value 为 “a,b,c,d”。B 执行操作添加一个 e，value 为”a,b,c,e”。如果不加控制，无论 A 和 B 谁先更新成功，它的更新都会被后到的更新覆盖。</p>
<p>Tair 无法解决这个问题，但是引入了 version 机制避免这样的问题。还是拿刚才的例子，A 和 B 取到数据，假设版本号为 10，A 先更新，更新成功后，value 为”a,b,c,d”，与此同时，版本号会变为 11。当 B 更新时，由于其基于的版本号是 10，服务器会拒绝更新，从而避免 A 的更新被覆盖。B 可以选择 get 新版本的 value，然后在其基础上修改，也可以选择强行更新。</p>
<h3 id="item-支持">Item 支持</h3>
<p>Tair 还支持将 value 视为一个 item 数组，对 value 中的部分 item 进行操作。比如有个 key 的 value 为 [1,2,3,4,5]，我们可以只获取前两个 item，返回 [1,2]，也可以删除第一个 item，还支持将数据删除，并返回被删除的数据，通过这个接口可以实现一个原子的分布式 FIFO 的队列。</p>
<h2 id="用途">用途</h2>
<h3 id="数据库缓存">数据库缓存</h3>
<p>随着业务量的增加，对数据库系统的并发请求越来越多，数据库系统的负载越来越重。当数据库系统过载时，响应速度会变慢，在极端情况下甚至会导致服务中断。</p>
<p>为了解决这个问题，Tair MDB 可以与数据库产品一起部署，以提供高吞吐量和低延迟的存储。</p>
<p>MDB 响应速度快，一般毫秒级完成请求。而且，MDB 支持更高的 QPS 速率，可以处理比数据库更多的并发请求。</p>
<p>通过观察业务，用户可以将热点数据存储在MDB中，显着减轻数据库的负载。这不仅降低了数据库成本，还提高了系统可用性。</p>
<h3 id="临时数据存储">临时数据存储</h3>
<p>社交网站、电商网站、游戏、广告等应用需要维护大量的临时数据。</p>
<p>在 MDB 中存储临时数据可以减少内存管理开销和应用程序负载。在分布式环境中，MDB可以作为统一的全局存储，可以防止单点故障造成的数据丢失，解决多个应用之间同步的问题。</p>
<p>一个常见的例子是使用 MDB 作为会话管理器。如果网站采用分布式部署，并且流量很大，同一用户的不同请求可能会发送到不同的Web服务器。</p>
<p>在这种情况下，MDB 可以作为全局存储解决方案来保存会话数据、用户令牌、权限信息等数据。</p>
<h3 id="数据存储">数据存储</h3>
<p>推荐和广告业务通常需要离线计算大量数据。 LDB 支持持久存储并提供卓越的性能。</p>
<p>支持在线服务，允许用户定期将离线数据导入LDB进行在线服务。</p>
<p>经过计算，列表业务可以将最终列表存储在LDB中，直接展示给前端应用程序。</p>
<p>这样，LDB 就满足了存储和高速访问的需求。</p>
<h3 id="黑名单白名单">黑名单/白名单</h3>
<p>安全应用程序有许多黑名单/白名单方案。这些黑名单/白名单场景的特点是命中率低、访问量大、数据丢失导致业务损失。</p>
<p>LDB 支持数据持久化和高访问量，因此在这些场景中被广泛使用。</p>
<h3 id="分布式锁">分布式锁</h3>
<p>分布式锁通常用于防止多线程并发导致的数据不一致和逻辑混乱。分布式锁可以使用 Tair 的版本特性或计算功能来实现。</p>
<p>得益于LBS的持久化，即使服务宕机，锁也不会丢失，可以正常释放。</p>
]]></description></item><item><title>程序员做需求时容易忽视的若干问题</title><link>https://xzygis.github.io/posts/some-problems-that-programmers-tend-to-ignore-when-making-requirements/</link><pubDate>Sun, 20 Nov 2022 23:33:08 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/some-problems-that-programmers-tend-to-ignore-when-making-requirements/</guid><description><![CDATA[<p>程序员大部分时间都在承接一个个的需求，在做需求的过程中，有一些问题是我们容易忽视的，究其原因，主要是在做需求的过程中缺少思考，或者思考不够全面。而思考的缺失，正是导致部分人所说的“做业务需求没有成长”的主要原因之一。今天主要从研发流程中重要的几个阶段出发，跟大家谈谈做需求的过程中有哪些是我们容易忽视的问题。</p>
<h2 id="需求分析">需求分析</h2>
<p>PM是我们的需求的最主要来源，在需求分析阶段，需要避免的问题是：一、没有理解清楚需求细节，而直接进入后续的方案设计和开发阶段；二、需求里说怎么干，我们就怎么干。
问题一容易造成的结果是，功能开发上线完成了，结果发现不是PM想要的，导致不必要的返工成本。另外，由于没有真正理清需求，也有可能导致项目的整体架构设计产生重大偏差，从而给后续的架构迭代留下隐患。
问题二容易造成的结果是，PM想做的功能点都做好了，却只是解决了一个本就不存在的问题，导致人力的浪费。特斯拉进行生产线自动化的时候，有一个零件的自动化安装总是出问题，特斯拉的工程师为了优化这个自动化流程，投入了大量的资金和精力。 后来马斯克问他们的技术人员，为什么需要这个零件，结果发现大家居然并不清楚。最后证明其实在电动车上，根本不需要这个零件。
为了避免以上两个问题，当我们接到PM需求时，应该详细地了解需求的功能细节，以及这个需求需要解决的问题是什么，最终是服务于什么目的，是否有助于达成业务的总体目标。以电商行业为例，我们应该思考所做的需求是否有助于提升商品的导购和流通效率，是否能帮卖家多挣钱，是否能帮买家更快找到想要的商品，是否能帮助平台提升竞争力。</p>
<h2 id="方案设计">方案设计</h2>
<p>在方案设计阶段，需要避免的问题是：“这个需求很简单，不用走方案设计和评审环节了，我直接开发吧，很快就可以上线了”。有些需求可能只是简单的修改一两个接口，或者只是对现有的流程做部分调整，这往往容易让我们过于自信，认为直接开干也不会有问题。其实，在我们真正理清楚方案之前，它并不简单，而确保我们真正理清方案的方式，就是按照部门的方案设计模板，把技术方案写出来，对照CheckList，逐一完成各个检查项。
所谓磨刀不误砍柴工，在方案设计阶段多花一些时间，可以帮助我们建设出更加合理的系统架构，让我们在技术架构上不断积累资产，资产的不断增值会让我们在能力建设和研发效率等方面长期受益。相反，如果我们忽视了方案设计，则会不断地积累技术债，后续需要投入很多精力去还债。</p>
<h2 id="代码开发">代码开发</h2>
<p>在代码开发方面，需要避免的问题是：“对工程质量要求低，认为能实现功能就行”。实际上，代码也是一种语言，它不仅用于人与机器之间的交流，而且也用于人与人之间的交流。逻辑复杂、晦涩难懂的代码可能会导致以下问题：一、隐藏bug，而且往往很不好改；二、后续有功能迭代时，逻辑修改非常复杂。
逻辑的正确性，是我们编码时的最低要求，编码时应该尽可能的追求信、达、雅。在编码方面主要给两点建议：一、遵守公司和部门的研发规范，包括分支规范、代码规范等；二、写代码时要多思考自己的写法是不是最优的，还有没有更好的写法。</p>
<h2 id="服务上线">服务上线</h2>
<p>在服务上线阶段，需要避免的是观察不细致，想当然的认为没问题，结果到最后导致了一个大问题。在上线阶段，我们应该加强检查，从多角度对服务进行观察，包括：上游角度、服务本身角度、下游角度，观察的指标，既包括错误率、时延、错误日志等通用指标，也包括业务自定义指标（应该在方案设计阶段考虑清楚后续有什么手段可以观测服务是否正常）。
值得一提的是，服务上线完成并不是结束，而是一个新的开始。我们需要采取各种手段保障服务的稳定运行，并不断发现其中的可优化点，推动服务SLI稳步提升。</p>
]]></description></item><item><title>给新人程序员的职场建议</title><link>https://xzygis.github.io/posts/career-advice-for-beginning-programmers/</link><pubDate>Sun, 20 Nov 2022 22:01:20 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/career-advice-for-beginning-programmers/</guid><description><![CDATA[<p>我是一位在大厂打拼多年的程序员，今天想结合自己的工作经历给新人程序员们提出若干建议，希望能够在一定程度上帮助大家在职场脱颖而出。</p>
<h2 id="积极主动">积极主动</h2>
<p>第一个建议是要积极主动，有owner意识，勇于承担工作职责，并在工作中做出成绩。
首先，领取任务或接受任务应该积极主动。在工作中可以主动向领导提出来自己对什么方向的项目感兴趣，希望承担什么样的任务。当领导知道你是积极主动的人，而且也发现你确实有能力胜任某项工作时，就会优先想到你。在领导主动布置工作任务时，也不应该过多的考虑这项工作好不好干、难度怎么样，而是应该要积极主动的接受。
其次，在执行任务的过程中，应该发挥主观能动性，从而使成果达到预期或尽可能的超出预期。这就要求我们理清任务的本质，思考任务背后的更深层次的逻辑，从而确定目标、理清思路、拆解任务、贯彻执行。这里特别需要避免的是，简单地成为“任务执行器”，即机械的执行任务，而不知道做完这个任务之后能解决什么问题，后续又还需要做什么。</p>
<h2 id="善于沟通">善于沟通</h2>
<p>作为研发，工作中不免要和很多同事进行沟通，比如跟PM对接需求、跟其他前后端RD聊技术方案、跟QA聊测试用例等，因此高效的沟通可以在很大程度上提升我们的工作效率。在善于沟通方面，主要的建议是：一、不要与人争吵；二、换位思考。
争吵不能解决任何的问题，反而容易让人丧失理智，而且容易影响自己在旁观者心里的印象。换位思考是解决沟通问题的利器，先谈对方最关心的点，让对方感受到你的真诚。遇到分歧时，先找共同点，求同存异，往往事半功倍。</p>
<h2 id="保持好奇心">保持好奇心</h2>
<p>软件研发方面的技术日新月异，不断有新的编程语言、存储组件、技术框架等出现，为了保持保持和增加自己的核心竞争力，对于工作中用到的相关组件和框架，应该不断去挖掘背后的底层原理。比如说工作中用到了HTTP协议，那么就应该思考：为什么会有HTTP？它的演进过程是怎样的？有什么设计理念是值得我们学习的？它还有什么缺陷是需要改进的吗？
除了熟悉工作中用到的技术组件的原理之外，也应该多关注一些前沿的技术趋势，了解业界同行的一些优秀的实践经验，可能的方式包括关注InfoQ、美团技术博客等公众号发布的高质量文档。
这里特别需要避免的是，整天抱怨自己的工作只是CRUD，认为自己的工作没价值，但是却不愿去发掘自己的工作背后的有价值的东西。</p>
<h2 id="引人注目">引人注目</h2>
<p>程序员是技术性很强的工作，技术是我们的立身之本，但我们也要避免只会研究技术、埋头苦干。对于交到我们手里的工作，我们要尽可能地做好，同时也需要积极地向领导汇报进展和成果，这样领导才会知道事情的进度是可控的、成果是可预期的，对于你个人的工作产出也自然心里有数了。
在引人注目方面，另外很重要的一点是：发表文章。如果只有你自己知道你是绝顶高手，是没有意义的，你需要通过发表文章的方式表述所学所思所想，让其他人知道你的实力，从而扩大你的影响力。</p>
]]></description></item><item><title>浅谈Bloom Filter基本原理及使用方式</title><link>https://xzygis.github.io/posts/introduction-to-the-basic-principles-of-bloom-filter/</link><pubDate>Sat, 12 Jun 2021 16:22:56 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/introduction-to-the-basic-principles-of-bloom-filter/</guid><description><![CDATA[<p>一提到元素查找，我们会很自然的想到<code>HashMap</code>。通过将哈希函数作用于key上，我们得到了哈希值，基于哈希值我们可以去表里的相应位置获取对应的数据。除了存在哈希冲突问题之外，<code>HashMap</code>一个很大的问题就是空间效率低。引入<code>Bloom Filter</code>则可以很好的解决空间效率的问题。</p>
<h2 id="原理">原理</h2>
<p>Bloom Filter是一种空间效率很高的随机数据结构，Bloom filter 可以看做是对bit-map 的扩展，布隆过滤器被设计为一个具有N的元素的位数组A（bit array），初始时所有的位都置为0。</p>
<p>当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位阵列（Bit array）中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了。</p>
<ul>
<li>如果这些点有任何一个 0，则被检索元素一定不在；</li>
<li>如果都是 1，则被检索元素很可能在。</li>
</ul>
<h2 id="添加元素">添加元素</h2>
<p>要添加一个元素，我们需要提供k个哈希函数。每个函数都能返回一个值，这个值必须能够作为位数组的索引（可以通过对数组长度进行取模得到）。然后，我们把位数组在这个索引处的值设为1。例如，第一个哈希函数作用于元素I上，返回x。类似的，第二个第三个哈希函数返回y与z，那么：
<code>A[x]=A[y]=A[z] = 1</code></p>
<h2 id="查找元素">查找元素</h2>
<p>查找的过程与上面的过程类似，元素将会被会被不同的哈希函数处理三次，每个哈希函数都返回一个作为位数组索引值的整数，然后我们检测位数组在x、y与z处的值是否为1。如果有一处不为1，那么就说明这个元素没有被添加到这个布隆过滤器中。如果都为1，就说明这个元素在布隆过滤器里面。当然，会有一定误判的概率。</p>
<h2 id="算法优化">算法优化</h2>
<p>通过上面的解释我们可以知道，如果想设计出一个好的布隆过滤器，我们必须遵循以下准则：</p>
<ul>
<li>好的哈希函数能够尽可能的返回宽范围的哈希值。</li>
<li>位数组的大小（用m表示）非常重要：如果太小，那么所有的位很快就都会被赋值为1，这样就增加了误判的几率。</li>
<li>哈希函数的个数（用k表示）对索引值的均匀分配也很重要。</li>
</ul>
<p>计算m的公式如下：
<code>m = - nlog p / (log2)^2</code>
这里p为可接受的误判率。</p>
<p>计算k的公式如下：
<code>k = m/n log(2)</code>
这里k=哈希函数个数，m=位数组个数，n=待检测元素的个数（后面会用到这几个字母）。</p>
<h2 id="哈希算法">哈希算法</h2>
<p>哈希算法是影响布隆过滤器性能的地方。我们需要选择一个效率高但不耗时的哈希函数，在论文《更少的哈希函数，相同的性能指标：构造一个更好的布隆过滤器》中，讨论了如何选用2个哈希函数来模拟k个哈希函数。首先，我们需要计算两个哈希函数h1(x)与h2(x)。然后，我们可以用这两个哈希函数来模仿产生k个哈希函数的效果：
<code>gi(x) = h1(x) + ih2(x)</code>
这里i的取值范围是1到k的整数。</p>
<p>Google Guava类库使用这个技巧实现了一个布隆过滤器，哈希算法的主要逻辑如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">long</span> <span class="n">hash64</span> <span class="o">=</span> <span class="o">...;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">hash1</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">hash64</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">hash2</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="n">hash64</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">32</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">numHashFunctions</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">combinedHash</span> <span class="o">=</span> <span class="n">hash1</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">hash2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Flip all the bits if it&#39;s negative (guaranteed positive number)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="o">(</span><span class="n">combinedHash</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">combinedHash</span> <span class="o">=</span> <span class="o">~</span><span class="n">combinedHash</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Guava中的Bloom Filter使用示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">expectedInsertions</span> <span class="o">=</span> <span class="o">...;</span> <span class="c1">//待检测元素的个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">double</span> <span class="n">fpp</span> <span class="o">=</span> <span class="mf">0.03</span><span class="o">;</span> <span class="c1">//误判率(desired false positive probability)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BloomFilter</span><span class="o">&lt;</span><span class="n">CharSequence</span><span class="o">&gt;</span> <span class="n">bloomFilter</span> <span class="o">=</span> <span class="n">BloomFilter</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">Funnels</span><span class="o">.</span><span class="na">stringFunnel</span><span class="o">(</span><span class="n">Charset</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;UTF-8&#34;</span><span class="o">)),</span> <span class="n">expectedInsertions</span><span class="o">,</span><span class="n">fpp</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="优点">优点</h2>
<p>它的优点是空间效率和查询时间都远远超过一般的算法，布隆过滤器存储空间和插入/查询时间都是常数O(k)。另外, 散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p>
<h2 id="缺点">缺点</h2>
<p>布隆过滤器的缺点和优点一样明显，误算率是其中之一。</p>
<p>另外，一般情况下不能从布隆过滤器中删除元素。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1，这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面，而这一点单凭这个过滤器是无法保证的。</p>
<p>参考来源：</p>
<ul>
<li><a href="https://www.javacodegeeks.com/2014/07/how-to-use-bloom-filter-to-build-a-large-in-memory-cache-in-java.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.javacodegeeks.com/2014/07/how-to-use-bloom-filter-to-build-a-large-in-memory-cache-in-java.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://www.cnblogs.com/haippy/archive/2012/07/13/2590351.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/haippy/archive/2012/07/13/2590351.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://segmentfault.com/a/1190000002729689"target="_blank" rel="external nofollow noopener noreferrer">https://segmentfault.com/a/1190000002729689<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
]]></description></item><item><title>Linux文件传输的三种方式</title><link>https://xzygis.github.io/posts/three-ways-to-transfer-files-in-linux/</link><pubDate>Sat, 12 Jun 2021 16:14:22 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/three-ways-to-transfer-files-in-linux/</guid><description><![CDATA[<h2 id="1-nc命令">1 nc命令</h2>
<p>执行如下命令，在目标机器(假设ip为<code>10.11.12.13</code>)上监听端口<code>8415</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">nc -l 8415 &gt; data.txt
</span></span></code></pre></td></tr></table>
</div>
</div><p>往目标机器发送数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">nc -v 10.11.12.13 8415 &lt; ~/Downloads/data.txt
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="2-simplehttpserver">2 SimpleHTTPServer</h2>
<p>在服务器(假设ip为<code>10.11.12.13</code>)上执行如下命令:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">python -m SimpleHTTPServer 8411 
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后在本地机器打开浏览器，输入<code>http://10.11.12.13:8411/</code>可以访问。</p>
<h2 id="3-scp命令">3 scp命令</h2>
<p>Linux scp命令用于Linux之间复制文件和目录。</p>
<p>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</p>
<p>在目标机器执行如下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">scp -l 700000 username@dev.test.com:~/data.txt ./ 
</span></span></code></pre></td></tr></table>
</div>
</div><p>即可把目标机器dev.test.com的文件~/data.txt拷贝到当前目录。</p>
]]></description></item><item><title>Websocket介绍</title><link>https://xzygis.github.io/posts/introduction-of-websocket/</link><pubDate>Sat, 12 Jun 2021 15:25:21 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/introduction-of-websocket/</guid><description><![CDATA[<h2 id="什么是websocket">什么是WebSocket？</h2>
<p>WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。WebSocket协议在2011年由IETF标准化为RFC 6455，后由RFC 7936补充规范。</p>
<p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p>
<h3 id="有哪些优点">有哪些优点？</h3>
<ol>
<li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</li>
<li>强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li>
<li>保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li>
<li>更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</li>
<li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li>
</ol>
<h2 id="握手协议">握手协议</h2>
<p>WebSocket是一种与HTTP不同的协议。两者都位于OSI模型的应用层，并且都依赖于传输层的TCP协议。 虽然它们不同，但是RFC 6455中规定：it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries（WebSocket通过HTTP端口80和443进行工作，并支持HTTP代理和中介），从而使其与HTTP协议兼容。 为了实现兼容性，WebSocket握手使用HTTP Upgrade头从HTTP协议更改为WebSocket协议。</p>
<h3 id="握手例子">握手例子</h3>
<p>一个典型的Websocket握手请求如下：</p>
<p>客户端请求：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">GET /chat HTTP/1.1
</span></span><span class="line"><span class="cl">Host: server.example.com
</span></span><span class="line"><span class="cl">Upgrade: websocket
</span></span><span class="line"><span class="cl">Connection: Upgrade
</span></span><span class="line"><span class="cl">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
</span></span><span class="line"><span class="cl">Origin: http://example.com
</span></span><span class="line"><span class="cl">Sec-WebSocket-Protocol: chat, superchat
</span></span><span class="line"><span class="cl">Sec-WebSocket-Version: 13
</span></span></code></pre></td></tr></table>
</div>
</div><p>服务器回应：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">HTTP/1.1 101 Switching Protocols
</span></span><span class="line"><span class="cl">Upgrade: websocket
</span></span><span class="line"><span class="cl">Connection: Upgrade
</span></span><span class="line"><span class="cl">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
</span></span><span class="line"><span class="cl">Sec-WebSocket-Protocol: chat
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="字段说明">字段说明</h3>
<ul>
<li>Connection必须设置Upgrade，表示客户端希望连接升级。</li>
<li>Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。</li>
<li>Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行Base64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。</li>
<li>Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。</li>
<li>Origin字段是必须的。如果缺少origin字段，WebSocket服务器需要回复HTTP 403 状态码（禁止访问）。</li>
</ul>
<h3 id="体验一下">体验一下</h3>
<blockquote>
<p><a href="https://www.websocket.org/echo.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.websocket.org/echo.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</blockquote>
<p></p>
<p>握手报文：</p>
<p></p>
<p>数据传输：</p>
<p></p>
<h2 id="数据帧">数据帧</h2>
<p>WebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。</p>
<ul>
<li>发送端：将消息切割成多个帧，并发送给服务端；</li>
<li>接收端：接收消息帧，并将关联的帧重新组装成完整的消息；</li>
</ul>
<h3 id="帧结构">帧结构</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> +-+-+-+-+-------+-+-------------+-------------------------------+
</span></span><span class="line"><span class="cl"> |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
</span></span><span class="line"><span class="cl"> |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
</span></span><span class="line"><span class="cl"> |N|V|V|V|       |S|             |   (if payload len==126/127)   |
</span></span><span class="line"><span class="cl"> | |1|2|3|       |K|             |                               |
</span></span><span class="line"><span class="cl"> +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
</span></span><span class="line"><span class="cl"> |     Extended payload length continued, if payload len == 127  |
</span></span><span class="line"><span class="cl"> + - - - - - - - - - - - - - - - +-------------------------------+
</span></span><span class="line"><span class="cl"> |                               |Masking-key, if MASK set to 1  |
</span></span><span class="line"><span class="cl"> +-------------------------------+-------------------------------+
</span></span><span class="line"><span class="cl"> | Masking-key (continued)       |          Payload Data         |
</span></span><span class="line"><span class="cl"> +-------------------------------- - - - - - - - - - - - - - - - +
</span></span><span class="line"><span class="cl"> :                     Payload Data continued ...                :
</span></span><span class="line"><span class="cl"> + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
</span></span><span class="line"><span class="cl"> |                     Payload Data continued ...                |
</span></span><span class="line"><span class="cl"> +---------------------------------------------------------------+
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="字段说明-1">字段说明</h3>
<p>FIN：1个比特。
如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。</p>
<p>RSV1, RSV2, RSV3：各占1个比特。
一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。</p>
<p>Opcode: 4个比特。
操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：</p>
<ul>
<li>%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。</li>
<li>%x1：表示这是一个文本帧（frame）</li>
<li>%x2：表示这是一个二进制帧（frame）</li>
<li>%x3-7：保留的操作代码，用于后续定义的非控制帧。</li>
<li>%x8：表示连接断开。</li>
<li>%x9：表示这是一个ping操作。</li>
<li>%xA：表示这是一个pong操作。</li>
<li>%xB-F：保留的操作代码，用于后续定义的控制帧。</li>
</ul>
<p>Mask: 1个比特。
表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。
如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。
如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。
掩码的算法、用途在下一小节讲解。</p>
<p>Payload length：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。
假设数Payload length === x，如果</p>
<ul>
<li>x为0~126：数据的长度为x字节。</li>
<li>x为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。</li>
<li>x为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。</li>
</ul>
<p>此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。</p>
<p>Masking-key：0或4字节（32位）
所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。
备注：载荷数据的长度，不包括mask key的长度。</p>
<p>Payload data：(x+y) 字节</p>
<ul>
<li>载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。</li>
<li>扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</li>
<li>应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。</li>
</ul>
<h3 id="掩码算法">掩码算法</h3>
<p>掩码键（Masking-key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：</p>
<p>首先，预设：</p>
<ul>
<li>original-octet-i：为原始数据的第i字节。</li>
<li>transformed-octet-i：为转换后的数据的第i字节。</li>
<li>j：为i mod 4的结果。</li>
<li>masking-key-octet-j：为mask key第j字节。</li>
</ul>
<p>流程为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。</p>
<p>伪代码大概是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">var DECODED = &#34;&#34;;
</span></span><span class="line"><span class="cl">for (var i = 0; i &lt; ENCODED.length; i++) {
</span></span><span class="line"><span class="cl">    DECODED[i] = ENCODED[i] ^ MASK[i % 4];
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>数据掩码的作用：
WebSocket 协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。
那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。
答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p>
<h2 id="数据传递">数据传递</h2>
<p>一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。
WebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。</p>
<h3 id="数据分片">数据分片</h3>
<p>WebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据FIN的值来判断，是否已经收到消息的最后一个数据帧。
FIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。
此外，opcode在数据交换的场景下，表示的是数据的类型。0x01表示文本，0x02表示二进制。而0x00比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</p>
<h3 id="数据分片例子">数据分片例子</h3>
<p>下面例子来自MDN，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。</p>
<p><em>第一条消息</em></p>
<p>FIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。</p>
<p><em>第二条消息</em></p>
<ol>
<li>FIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。</li>
<li>FIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。</li>
<li>FIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Client: FIN=1, opcode=0x1, msg=&#34;hello&#34;
</span></span><span class="line"><span class="cl">Server: (process complete message immediately) Hi.
</span></span><span class="line"><span class="cl">Client: FIN=0, opcode=0x1, msg=&#34;and a&#34;
</span></span><span class="line"><span class="cl">Server: (listening, new message containing text started)
</span></span><span class="line"><span class="cl">Client: FIN=0, opcode=0x0, msg=&#34;happy new&#34;
</span></span><span class="line"><span class="cl">Server: (listening, payload concatenated to previous message)
</span></span><span class="line"><span class="cl">Client: FIN=1, opcode=0x0, msg=&#34;year!&#34;
</span></span><span class="line"><span class="cl">Server: (process complete message) Happy new year to you too!
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="心跳">心跳</h2>
<p>WebSocket 为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的 TCP 通道保持连接没有断开。
对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p>
<ul>
<li>发送方 -&gt; 接收方：ping</li>
<li>接收方 -&gt; 发送方：pong</li>
</ul>
<p>ping、pong 的操作，对应的是 WebSocket 的两个控制帧，opcode分别是0x9、0xA。</p>
<h2 id="安全性">安全性</h2>
<p>WebSocket协议中规定在连接建立时检查Upgrade请求中的某些字段（如Origin，查看每次请求是否一致），对于不符合要求的请求立即断开，在通信过程中，也对Frame中的控制位做了很多限制，以便禁止异常连接。
websocket协议中也规定了数据加密传输的方式，允许使用TLS/SSL来对通信加密，默认ws的端口为80，wss端口为433，类似HTTP与HTTPS。</p>
<h2 id="go实战gorilla-websocket">Go实战：Gorilla WebSocket</h2>
<blockquote>
<p>Github：https://github.com/gorilla/websocket</p>
</blockquote>
<p>文件监控例子（当文件被修改后，把文件发给客户端）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func main() {
</span></span><span class="line"><span class="cl">   http.HandleFunc(&#34;/ws&#34;, serveWs)
</span></span><span class="line"><span class="cl">   if err := http.ListenAndServe(*addr, nil); err != nil {
</span></span><span class="line"><span class="cl">      log.Fatal(err)
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func serveWs(w http.ResponseWriter, r *http.Request) {
</span></span><span class="line"><span class="cl">   //升级为Websocket协议
</span></span><span class="line"><span class="cl">   ws, err := upgrader.Upgrade(w, r, nil)
</span></span><span class="line"><span class="cl">   if err != nil {
</span></span><span class="line"><span class="cl">      if _, ok := err.(websocket.HandshakeError); !ok {
</span></span><span class="line"><span class="cl">         log.Println(err)
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      return
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   var lastMod time.Time
</span></span><span class="line"><span class="cl">   if n, err := strconv.ParseInt(r.FormValue(&#34;lastMod&#34;), 16, 64); err == nil {
</span></span><span class="line"><span class="cl">      lastMod = time.Unix(0, n)
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   go writer(ws, lastMod) //发送数据、Pong
</span></span><span class="line"><span class="cl">   reader(ws) //读数据、处理Ping
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func writer(ws *websocket.Conn, lastMod time.Time) {
</span></span><span class="line"><span class="cl">   pingTicker := time.NewTicker(pingPeriod)
</span></span><span class="line"><span class="cl">   fileTicker := time.NewTicker(filePeriod)
</span></span><span class="line"><span class="cl">   ...
</span></span><span class="line"><span class="cl">   for {
</span></span><span class="line"><span class="cl">      select {
</span></span><span class="line"><span class="cl">      case &lt;-fileTicker.C:
</span></span><span class="line"><span class="cl">         p, fileModified, err := readFileIfModified(lastMod)
</span></span><span class="line"><span class="cl">         ...
</span></span><span class="line"><span class="cl">         if fileModified {
</span></span><span class="line"><span class="cl">            ws.SetWriteDeadline(time.Now().Add(writeWait))
</span></span><span class="line"><span class="cl">            if err := ws.WriteMessage(websocket.TextMessage, p); err != nil {
</span></span><span class="line"><span class="cl">               return
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">         }
</span></span><span class="line"><span class="cl">      case &lt;-pingTicker.C:
</span></span><span class="line"><span class="cl">         ws.SetWriteDeadline(time.Now().Add(writeWait))
</span></span><span class="line"><span class="cl">         if err := ws.WriteMessage(websocket.PingMessage, []byte{}); err != nil {
</span></span><span class="line"><span class="cl">            return
</span></span><span class="line"><span class="cl">         }
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func reader(ws *websocket.Conn) {
</span></span><span class="line"><span class="cl">   defer ws.Close()
</span></span><span class="line"><span class="cl">   ws.SetReadLimit(512)
</span></span><span class="line"><span class="cl">   ws.SetReadDeadline(time.Now().Add(pongWait))
</span></span><span class="line"><span class="cl">   ws.SetPongHandler(func(string) error { ws.SetReadDeadline(time.Now().Add(pongWait)); return nil })
</span></span><span class="line"><span class="cl">   for {
</span></span><span class="line"><span class="cl">      _, _, err := ws.ReadMessage()
</span></span><span class="line"><span class="cl">      if err != nil {
</span></span><span class="line"><span class="cl">         break
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中最重要的几个方法是Upgrade、ReadMessage和WriteMessage，下面逐一介绍。</p>
<h3 id="upgrade">Upgrade</h3>
<p>协议升级</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// Upgrade upgrades the HTTP server connection to the WebSocket protocol.
</span></span><span class="line"><span class="cl">func (u *Upgrader) Upgrade(w http.ResponseWriter, r *http.Request, responseHeader http.Header) (*Conn, error) {
</span></span><span class="line"><span class="cl">   const badHandshake = &#34;websocket: the client is not using the websocket protocol: &#34;
</span></span><span class="line"><span class="cl">   //检查必要的头部字段
</span></span><span class="line"><span class="cl">   if !tokenListContainsValue(r.Header, &#34;Connection&#34;, &#34;upgrade&#34;) {
</span></span><span class="line"><span class="cl">      return u.returnError(w, r, http.StatusBadRequest, badHandshake+&#34;&#39;upgrade&#39; token not found in &#39;Connection&#39; header&#34;)
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if !tokenListContainsValue(r.Header, &#34;Upgrade&#34;, &#34;websocket&#34;) {
</span></span><span class="line"><span class="cl">      return u.returnError(w, r, http.StatusBadRequest, badHandshake+&#34;&#39;websocket&#39; token not found in &#39;Upgrade&#39; header&#34;)
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if r.Method != &#34;GET&#34; {
</span></span><span class="line"><span class="cl">      return u.returnError(w, r, http.StatusMethodNotAllowed, badHandshake+&#34;request method is not GET&#34;)
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if !tokenListContainsValue(r.Header, &#34;Sec-Websocket-Version&#34;, &#34;13&#34;) {
</span></span><span class="line"><span class="cl">      return u.returnError(w, r, http.StatusBadRequest, &#34;websocket: unsupported version: 13 not found in &#39;Sec-Websocket-Version&#39; header&#34;)
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if !checkOrigin(r) {
</span></span><span class="line"><span class="cl">      return u.returnError(w, r, http.StatusForbidden, &#34;websocket: request origin not allowed by Upgrader.CheckOrigin&#34;)
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   challengeKey := r.Header.Get(&#34;Sec-Websocket-Key&#34;)
</span></span><span class="line"><span class="cl">   if challengeKey == &#34;&#34; {
</span></span><span class="line"><span class="cl">      return u.returnError(w, r, http.StatusBadRequest, &#34;websocket: not a websocket handshake: &#39;Sec-WebSocket-Key&#39; header is missing or blank&#34;)
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   h, ok := w.(http.Hijacker)
</span></span><span class="line"><span class="cl">   if !ok {
</span></span><span class="line"><span class="cl">      return u.returnError(w, r, http.StatusInternalServerError, &#34;websocket: response does not implement http.Hijacker&#34;)
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">   //创建websocket.Conn
</span></span><span class="line"><span class="cl">   c := newConn(netConn, true, u.ReadBufferSize, u.WriteBufferSize, u.WriteBufferPool, br, writeBuf)
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">   var p []byte
</span></span><span class="line"><span class="cl">   p = append(p, &#34;HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: &#34;...)
</span></span><span class="line"><span class="cl">   p = append(p, computeAcceptKey(challengeKey)...) //计算accept
</span></span><span class="line"><span class="cl">   p = append(p, &#34;\r\n&#34;...)
</span></span><span class="line"><span class="cl">   if c.subprotocol != &#34;&#34; {
</span></span><span class="line"><span class="cl">      p = append(p, &#34;Sec-WebSocket-Protocol: &#34;...)
</span></span><span class="line"><span class="cl">      p = append(p, c.subprotocol...)
</span></span><span class="line"><span class="cl">      p = append(p, &#34;\r\n&#34;...)
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if _, err = netConn.Write(p); err != nil {
</span></span><span class="line"><span class="cl">      netConn.Close()
</span></span><span class="line"><span class="cl">      return nil, err
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   return c, nil
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">var keyGUID = []byte(&#34;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#34;)
</span></span><span class="line"><span class="cl">func computeAcceptKey(challengeKey string) string {
</span></span><span class="line"><span class="cl">   h := sha1.New()
</span></span><span class="line"><span class="cl">   h.Write([]byte(challengeKey))
</span></span><span class="line"><span class="cl">   h.Write(keyGUID)
</span></span><span class="line"><span class="cl">   return base64.StdEncoding.EncodeToString(h.Sum(nil))
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func newConn(conn net.Conn, isServer bool, readBufferSize, writeBufferSize int, writeBufferPool BufferPool, br *bufio.Reader, writeBuf []byte) *Conn {
</span></span><span class="line"><span class="cl">   c := &amp;Conn{
</span></span><span class="line"><span class="cl">      isServer:               isServer,
</span></span><span class="line"><span class="cl">      br:                     br,
</span></span><span class="line"><span class="cl">      conn:                   conn,
</span></span><span class="line"><span class="cl">      mu:                     mu,
</span></span><span class="line"><span class="cl">      readFinal:              true,
</span></span><span class="line"><span class="cl">      writeBuf:               writeBuf,
</span></span><span class="line"><span class="cl">      writePool:              writeBufferPool,
</span></span><span class="line"><span class="cl">      writeBufSize:           writeBufferSize,
</span></span><span class="line"><span class="cl">      enableWriteCompression: true,
</span></span><span class="line"><span class="cl">      compressionLevel:       defaultCompressionLevel,
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">   //设置对应的消息处理Handler
</span></span><span class="line"><span class="cl">   c.SetCloseHandler(nil)
</span></span><span class="line"><span class="cl">   c.SetPingHandler(nil)
</span></span><span class="line"><span class="cl">   c.SetPongHandler(nil)
</span></span><span class="line"><span class="cl">   return c
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (c *Conn) SetCloseHandler(h func(code int, text string) error) {
</span></span><span class="line"><span class="cl">   if h == nil {
</span></span><span class="line"><span class="cl">      h = func(code int, text string) error {
</span></span><span class="line"><span class="cl">         message := FormatCloseMessage(code, &#34;&#34;)
</span></span><span class="line"><span class="cl">         c.WriteControl(CloseMessage, message, time.Now().Add(writeWait))
</span></span><span class="line"><span class="cl">         return nil
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   c.handleClose = h
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (c *Conn) SetPingHandler(h func(appData string) error) {
</span></span><span class="line"><span class="cl">   if h == nil {
</span></span><span class="line"><span class="cl">      h = func(message string) error {
</span></span><span class="line"><span class="cl">         err := c.WriteControl(PongMessage, []byte(message), time.Now().Add(writeWait))
</span></span><span class="line"><span class="cl">         return err
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   c.handlePing = h
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (c *Conn) SetPongHandler(h func(appData string) error) {
</span></span><span class="line"><span class="cl">   if h == nil {
</span></span><span class="line"><span class="cl">      h = func(string) error { return nil }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   c.handlePong = h
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="readmessage">ReadMessage</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (c *Conn) ReadMessage() (messageType int, p []byte, err error) {
</span></span><span class="line"><span class="cl">   var r io.Reader
</span></span><span class="line"><span class="cl">   messageType, r, err = c.NextReader()
</span></span><span class="line"><span class="cl">   if err != nil {
</span></span><span class="line"><span class="cl">      return messageType, nil, err
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   p, err = ioutil.ReadAll(r)
</span></span><span class="line"><span class="cl">   return messageType, p, err
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (c *Conn) NextReader() (messageType int, r io.Reader, err error) {
</span></span><span class="line"><span class="cl">   for c.readErr == nil {
</span></span><span class="line"><span class="cl">       frameType, err := c.advanceFrame()
</span></span><span class="line"><span class="cl">       if err != nil {
</span></span><span class="line"><span class="cl">          c.readErr = hideTempErr(err)
</span></span><span class="line"><span class="cl">          break
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">       if frameType == TextMessage || frameType == BinaryMessage {
</span></span><span class="line"><span class="cl">          c.messageReader = &amp;messageReader{c}
</span></span><span class="line"><span class="cl">          c.reader = c.messageReader
</span></span><span class="line"><span class="cl">          if c.readDecompress {
</span></span><span class="line"><span class="cl">             c.reader = c.newDecompressionReader(c.reader)
</span></span><span class="line"><span class="cl">          }
</span></span><span class="line"><span class="cl">          return frameType, c.reader, nil
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//解析数据帧
</span></span><span class="line"><span class="cl">func (c *Conn) advanceFrame() (int, error) {
</span></span><span class="line"><span class="cl">   p, err := c.read(2)
</span></span><span class="line"><span class="cl">   final := p[0]&amp;finalBit != 0
</span></span><span class="line"><span class="cl">   frameType := int(p[0] &amp; 0xf)
</span></span><span class="line"><span class="cl">   mask := p[1]&amp;maskBit != 0
</span></span><span class="line"><span class="cl">   c.setReadRemaining(int64(p[1] &amp; 0x7f))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   switch frameType {
</span></span><span class="line"><span class="cl">   case CloseMessage, PingMessage, PongMessage:
</span></span><span class="line"><span class="cl">      if c.readRemaining &gt; maxControlFramePayloadSize {
</span></span><span class="line"><span class="cl">         return noFrame, c.handleProtocolError(&#34;control frame length &gt; 125&#34;)
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      if !final {
</span></span><span class="line"><span class="cl">         return noFrame, c.handleProtocolError(&#34;control frame not final&#34;)
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">   case TextMessage, BinaryMessage:
</span></span><span class="line"><span class="cl">      if !c.readFinal {
</span></span><span class="line"><span class="cl">         return noFrame, c.handleProtocolError(&#34;message start before final message frame&#34;)
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      c.readFinal = final
</span></span><span class="line"><span class="cl">   case continuationFrame:
</span></span><span class="line"><span class="cl">      if c.readFinal {
</span></span><span class="line"><span class="cl">         return noFrame, c.handleProtocolError(&#34;continuation after final message frame&#34;)
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      c.readFinal = final
</span></span><span class="line"><span class="cl">   default:
</span></span><span class="line"><span class="cl">      return noFrame, c.handleProtocolError(&#34;unknown opcode &#34; + strconv.Itoa(frameType))
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">   switch c.readRemaining {
</span></span><span class="line"><span class="cl">   case 126:
</span></span><span class="line"><span class="cl">      p, err := c.read(2)
</span></span><span class="line"><span class="cl">      if err := c.setReadRemaining(int64(binary.BigEndian.Uint16(p))); err != nil {
</span></span><span class="line"><span class="cl">         return noFrame, err
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">   case 127:
</span></span><span class="line"><span class="cl">      p, err := c.read(8)
</span></span><span class="line"><span class="cl">      if err != nil {
</span></span><span class="line"><span class="cl">         return noFrame, err
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      if err := c.setReadRemaining(int64(binary.BigEndian.Uint64(p))); err != nil {
</span></span><span class="line"><span class="cl">         return noFrame, err
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if mask != c.isServer {
</span></span><span class="line"><span class="cl">      return noFrame, c.handleProtocolError(&#34;incorrect mask flag&#34;)
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if mask {
</span></span><span class="line"><span class="cl">      c.readMaskPos = 0
</span></span><span class="line"><span class="cl">      p, err := c.read(len(c.readMaskKey))
</span></span><span class="line"><span class="cl">      if err != nil {
</span></span><span class="line"><span class="cl">         return noFrame, err
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      copy(c.readMaskKey[:], p)
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   //处理控制帧
</span></span><span class="line"><span class="cl">   switch frameType {
</span></span><span class="line"><span class="cl">   case PongMessage:
</span></span><span class="line"><span class="cl">      if err := c.handlePong(string(payload)); err != nil {
</span></span><span class="line"><span class="cl">         return noFrame, err
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">   case PingMessage:
</span></span><span class="line"><span class="cl">      if err := c.handlePing(string(payload)); err != nil {
</span></span><span class="line"><span class="cl">         return noFrame, err
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">   case CloseMessage:
</span></span><span class="line"><span class="cl">      closeCode := CloseNoStatusReceived
</span></span><span class="line"><span class="cl">      closeText := &#34;&#34;
</span></span><span class="line"><span class="cl">      if len(payload) &gt;= 2 {
</span></span><span class="line"><span class="cl">         closeCode = int(binary.BigEndian.Uint16(payload))
</span></span><span class="line"><span class="cl">         if !isValidReceivedCloseCode(closeCode) {
</span></span><span class="line"><span class="cl">            return noFrame, c.handleProtocolError(&#34;invalid close code&#34;)
</span></span><span class="line"><span class="cl">         }
</span></span><span class="line"><span class="cl">         closeText = string(payload[2:])
</span></span><span class="line"><span class="cl">         if !utf8.ValidString(closeText) {
</span></span><span class="line"><span class="cl">            return noFrame, c.handleProtocolError(&#34;invalid utf8 payload in close frame&#34;)
</span></span><span class="line"><span class="cl">         }
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      if err := c.handleClose(closeCode, closeText); err != nil {
</span></span><span class="line"><span class="cl">         return noFrame, err
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      return noFrame, &amp;CloseError{Code: closeCode, Text: closeText}
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   return frameType, nil
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="writemessage">WriteMessage</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (c *Conn) WriteMessage(messageType int, data []byte) error {
</span></span><span class="line"><span class="cl">   var mw messageWriter
</span></span><span class="line"><span class="cl">   // beginMessage prepares a connection and message writer for a new message.
</span></span><span class="line"><span class="cl">    if err := c.beginMessage(&amp;mw, messageType); err != nil {
</span></span><span class="line"><span class="cl">       return err
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    n := copy(c.writeBuf[mw.pos:], data)
</span></span><span class="line"><span class="cl">    mw.pos += n
</span></span><span class="line"><span class="cl">    data = data[n:]
</span></span><span class="line"><span class="cl">    return mw.flushFrame(true, data)
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//组装数据帧
</span></span><span class="line"><span class="cl">func (w *messageWriter) flushFrame(final bool, extra []byte) error {
</span></span><span class="line"><span class="cl">   c := w.c
</span></span><span class="line"><span class="cl">   length := w.pos - maxFrameHeaderSize + len(extra)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   b0 := byte(w.frameType)
</span></span><span class="line"><span class="cl">   if final {
</span></span><span class="line"><span class="cl">      b0 |= finalBit
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   if w.compress {
</span></span><span class="line"><span class="cl">      b0 |= rsv1Bit
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   w.compress = false
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   b1 := byte(0)
</span></span><span class="line"><span class="cl">   if !c.isServer {
</span></span><span class="line"><span class="cl">      b1 |= maskBit
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   // Assume that the frame starts at beginning of c.writeBuf.
</span></span><span class="line"><span class="cl">   framePos := 0
</span></span><span class="line"><span class="cl">   if c.isServer {
</span></span><span class="line"><span class="cl">      // Adjust up if mask not included in the header.
</span></span><span class="line"><span class="cl">      framePos = 4
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   switch {
</span></span><span class="line"><span class="cl">   case length &gt;= 65536:
</span></span><span class="line"><span class="cl">      c.writeBuf[framePos] = b0
</span></span><span class="line"><span class="cl">      c.writeBuf[framePos+1] = b1 | 127
</span></span><span class="line"><span class="cl">      binary.BigEndian.PutUint64(c.writeBuf[framePos+2:], uint64(length))
</span></span><span class="line"><span class="cl">   case length &gt; 125:
</span></span><span class="line"><span class="cl">      framePos += 6
</span></span><span class="line"><span class="cl">      c.writeBuf[framePos] = b0
</span></span><span class="line"><span class="cl">      c.writeBuf[framePos+1] = b1 | 126
</span></span><span class="line"><span class="cl">      binary.BigEndian.PutUint16(c.writeBuf[framePos+2:], uint16(length))
</span></span><span class="line"><span class="cl">   default:
</span></span><span class="line"><span class="cl">      framePos += 8
</span></span><span class="line"><span class="cl">      c.writeBuf[framePos] = b0
</span></span><span class="line"><span class="cl">      c.writeBuf[framePos+1] = b1 | byte(length)
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if !c.isServer {
</span></span><span class="line"><span class="cl">      key := newMaskKey()
</span></span><span class="line"><span class="cl">      copy(c.writeBuf[maxFrameHeaderSize-4:], key[:])
</span></span><span class="line"><span class="cl">      maskBytes(key, 0, c.writeBuf[maxFrameHeaderSize:w.pos])
</span></span><span class="line"><span class="cl">      if len(extra) &gt; 0 {
</span></span><span class="line"><span class="cl">         return w.endMessage(c.writeFatal(errors.New(&#34;websocket: internal error, extra used in client mode&#34;)))
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   // Write the buffers to the connection with best-effort detection of
</span></span><span class="line"><span class="cl">   // concurrent writes. See the concurrency section in the package
</span></span><span class="line"><span class="cl">   // documentation for more info.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if c.isWriting {
</span></span><span class="line"><span class="cl">      panic(&#34;concurrent write to websocket connection&#34;)
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   c.isWriting = true
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   err := c.write(w.frameType, c.writeDeadline, c.writeBuf[framePos:w.pos], extra)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   ...
</span></span><span class="line"><span class="cl">   return nil
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Ref：</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc6455#"target="_blank" rel="external nofollow noopener noreferrer">https://datatracker.ietf.org/doc/html/rfc6455#<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://zh.wikipedia.org/wiki/WebSocket"target="_blank" rel="external nofollow noopener noreferrer">https://zh.wikipedia.org/wiki/WebSocket<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html"target="_blank" rel="external nofollow noopener noreferrer">http://www.ruanyifeng.com/blog/2017/05/websocket.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://pkg.go.dev/github.com/gorilla/websocket"target="_blank" rel="external nofollow noopener noreferrer">https://pkg.go.dev/github.com/gorilla/websocket<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
]]></description></item><item><title>Consul入门手册</title><link>https://xzygis.github.io/posts/manual-of-consul/</link><pubDate>Thu, 30 Jan 2020 13:35:59 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/manual-of-consul/</guid><description><![CDATA[<h2 id="consul是什么">Consul是什么？</h2>
<p>Consul是一个服务发现和配置工具，它是分布式和高可用的，而且极易扩展。</p>
<p>Consul主要提供了以下特性：</p>
<ol>
<li>服务发现：Consul使得服务注册和服务发现（通过DNS或HTTP接口）变得非常简单。</li>
<li>健康检查：健康检查使得Consul可以快速向管理员报告集群状况。将它与服务发现集成，可以防止流量路由到故障节点，实现服务熔断。</li>
<li>KV存储：灵活的KV存储，可用于尺寸出动态配置、功能特性、协调信息和选举信息等。简单的HTTP API使其易于在任何地方地方。</li>
<li>多数据中心：Consul支持多数据中心，不需要负责的配置就可以支持任意数量的数据中心。</li>
<li>服务鉴权（Service Segmentation）：Consul连接基于自动TLS加密和基于签名的鉴权实现安全的服务间通信。</li>
</ol>
<p>Consul支持Linux, Mac OS X, FreeBSD, Solaris, Windows等操作系统。</p>
<h3 id="基本架构">基本架构</h3>
<p>每个提供服务给Consul的节点都运行了一个Consul Agent。运行一个Agent并不需要对其他服务做发现或读写KV存储。Agent负责对该节点上的服务做健康检查。</p>
<p>Agent会与一个或多个Consul Server通信。Consul Server通常有多个实例，负责数据存储和备份、选举主节点等。虽然Consul支持在只有一个Server实例的情况下工具，但通常推荐使用3至5个实例，从而避免由于某些异常场景而导致数据丢失。同时，推荐在每个数据中心部署一个Consul集群。</p>
<p>每个数据中运行了一个Consul server集群。当一个跨数据中心的服务发现和配置请求创建时，本地Consul Server转发请求到远程的数据中心并返回结果.</p>
<h2 id="安装consul">安装Consul</h2>
<p>Consul集群的每个节点都必须先安装Consul，安装非常简单。在Mac上安装Consul命令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ brew install consul
</span></span></code></pre></td></tr></table>
</div>
</div><p>安装成功后执行consul命令输出如下结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ consul
</span></span><span class="line"><span class="cl">Usage: consul [--version] [--help] &lt;command&gt; [&lt;args&gt;]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Available commands are:
</span></span><span class="line"><span class="cl">    acl            Interact with Consul&#39;s ACLs
</span></span><span class="line"><span class="cl">    agent          Runs a Consul agent
</span></span><span class="line"><span class="cl">    catalog        Interact with the catalog
</span></span><span class="line"><span class="cl">    config         Interact with Consul&#39;s Centralized Configurations
</span></span><span class="line"><span class="cl">    connect        Interact with Consul Connect
</span></span><span class="line"><span class="cl">    debug          Records a debugging archive for operators
</span></span><span class="line"><span class="cl">    event          Fire a new event
</span></span><span class="line"><span class="cl">    exec           Executes a command on Consul nodes
</span></span><span class="line"><span class="cl">    force-leave    Forces a member of the cluster to enter the &#34;left&#34; state
</span></span><span class="line"><span class="cl">    info           Provides debugging information for operators.
</span></span><span class="line"><span class="cl">    intention      Interact with Connect service intentions
</span></span><span class="line"><span class="cl">    join           Tell Consul agent to join cluster
</span></span><span class="line"><span class="cl">    keygen         Generates a new encryption key
</span></span><span class="line"><span class="cl">    keyring        Manages gossip layer encryption keys
</span></span><span class="line"><span class="cl">    kv             Interact with the key-value store
</span></span><span class="line"><span class="cl">    leave          Gracefully leaves the Consul cluster and shuts down
</span></span><span class="line"><span class="cl">    lock           Execute a command holding a lock
</span></span><span class="line"><span class="cl">    login          Login to Consul using an auth method
</span></span><span class="line"><span class="cl">    logout         Destroy a Consul token created with login
</span></span><span class="line"><span class="cl">    maint          Controls node or service maintenance mode
</span></span><span class="line"><span class="cl">    members        Lists the members of a Consul cluster
</span></span><span class="line"><span class="cl">    monitor        Stream logs from a Consul agent
</span></span><span class="line"><span class="cl">    operator       Provides cluster-level tools for Consul operators
</span></span><span class="line"><span class="cl">    reload         Triggers the agent to reload configuration files
</span></span><span class="line"><span class="cl">    rtt            Estimates network round trip time between nodes
</span></span><span class="line"><span class="cl">    services       Interact with services
</span></span><span class="line"><span class="cl">    snapshot       Saves, restores and inspects snapshots of Consul server state
</span></span><span class="line"><span class="cl">    tls            Builtin helpers for creating CAs and certificates
</span></span><span class="line"><span class="cl">    validate       Validate config files/directories
</span></span><span class="line"><span class="cl">    version        Prints the Consul version
</span></span><span class="line"><span class="cl">    watch          Watch for changes in Consul
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="运行agent">运行Agent</h2>
<p>完成Consul的安装后，可运行Agent。Agent可以运行为Server或Client模式。每个数据中心至少必须拥有一台server，建议在一个集群中部署或者3至5个Server。部署单一的Server，在出现失败时会不可避免的造成数据丢失.</p>
<p>其他的Agent运行为Client模式，一个Client是一个非常轻量级的进程，用于注册服务，运行健康检查和转发对Server的查询，Agent必须在集群中的每个主机上运行。</p>
<h3 id="启动agent">启动Agent</h3>
<p>命令<code>consul agent -dev</code>可以启动一个开发模式的Agent，这种模式不能用于生产环境，因为它不持久化任何状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ consul agent -dev
</span></span><span class="line"><span class="cl">==&gt; Starting Consul agent...
</span></span><span class="line"><span class="cl">           Version: &#39;v1.6.1&#39;
</span></span><span class="line"><span class="cl">           Node ID: &#39;2e524113-7caf-643a-80bb-a2fa00c2673b&#39;
</span></span><span class="line"><span class="cl">         Node name: &#39;C02Z35N9LVCF&#39;
</span></span><span class="line"><span class="cl">        Datacenter: &#39;dc1&#39; (Segment: &#39;&lt;all&gt;&#39;)
</span></span><span class="line"><span class="cl">            Server: true (Bootstrap: false)
</span></span><span class="line"><span class="cl">       Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, gRPC: 8502, DNS: 8600)
</span></span><span class="line"><span class="cl">      Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302)
</span></span><span class="line"><span class="cl">           Encrypt: Gossip: false, TLS-Outgoing: false, TLS-Incoming: false, Auto-Encrypt-TLS: false
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">==&gt; Log data will now stream in as it occurs:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [DEBUG] agent: Using random ID &#34;2e524113-7caf-643a-80bb-a2fa00c2673b&#34; as node ID
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [DEBUG] tlsutil: Update with version 1
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [DEBUG] tlsutil: OutgoingRPCWrapper with version 1
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO]  raft: Initial configuration (index=1): [{Suffrage:Voter ID:2e524113-7caf-643a-80bb-a2fa00c2673b Address:127.0.0.1:8300}]
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO]  raft: Node at 127.0.0.1:8300 [Follower] entering Follower state (Leader: &#34;&#34;)
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO] serf: EventMemberJoin: C02Z35N9LVCF.dc1 127.0.0.1
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO] serf: EventMemberJoin: C02Z35N9LVCF 127.0.0.1
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO] consul: Adding LAN server C02Z35N9LVCF (Addr: tcp/127.0.0.1:8300) (DC: dc1)
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO] consul: Handled member-join event for server &#34;C02Z35N9LVCF.dc1&#34; in area &#34;wan&#34;
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO] agent: Started DNS server 127.0.0.1:8600 (tcp)
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO] agent: Started DNS server 127.0.0.1:8600 (udp)
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO] agent: Started HTTP server on 127.0.0.1:8500 (tcp)
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO] agent: Started gRPC server on 127.0.0.1:8502 (tcp)
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO] agent: started state syncer
</span></span><span class="line"><span class="cl">==&gt; Consul agent running!
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [WARN]  raft: Heartbeat timeout from &#34;&#34; reached, starting election
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO]  raft: Node at 127.0.0.1:8300 [Candidate] entering Candidate state in term 2
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [DEBUG] raft: Votes needed: 1
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [DEBUG] raft: Vote granted from 2e524113-7caf-643a-80bb-a2fa00c2673b in term 2. Tally: 1
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO]  raft: Election won. Tally: 1
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO]  raft: Node at 127.0.0.1:8300 [Leader] entering Leader state
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO] consul: cluster leadership acquired
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO] consul: New leader elected: C02Z35N9LVCF
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO] connect: initialized primary datacenter CA with provider &#34;consul&#34;
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [DEBUG] consul: Skipping self join check for &#34;C02Z35N9LVCF&#34; since the cluster is too small
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO] consul: member &#39;C02Z35N9LVCF&#39; joined, marking health alive
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [DEBUG] agent: Skipping remote check &#34;serfHealth&#34; since it is managed automatically
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [INFO] agent: Synced node info
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [DEBUG] agent: Node info in sync
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [DEBUG] agent: Skipping remote check &#34;serfHealth&#34; since it is managed automatically
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:09 [DEBUG] agent: Node info in sync
</span></span><span class="line"><span class="cl">    2019/11/20 21:56:11 [DEBUG] tlsutil: OutgoingRPCWrapper with version 1
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="集群成员">集群成员</h3>
<p>新开一个终端窗口运行<code>consul members</code>, 就可以看到Consul集群的成员。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ consul members
</span></span><span class="line"><span class="cl">Node          Address         Status  Type    Build  Protocol  DC   Segment
</span></span><span class="line"><span class="cl">C02Z35N9LVCF  127.0.0.1:8301  alive   server  1.6.1  2         dc1  &lt;all&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>以上输出显示了我们自己的节点运行的节点、地址、健康状态、自己在集群中的角色、版本信息等。添加<code>-detailed</code>选项可以查看到额外的信息，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ consul members --detailed
</span></span><span class="line"><span class="cl">Node          Address         Status  Tags
</span></span><span class="line"><span class="cl">C02Z35N9LVCF  127.0.0.1:8301  alive   acls=0,build=1.6.1:9be6dfc+,dc=dc1,id=2e524113-7caf-643a-80bb-a2fa00c2673b,port=8300,raft_vsn=3,role=consul,segment=&lt;all&gt;,vsn=2,vsn_max=3,vsn_min=2,wan_join_port=8302
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>members</code>命令的输出是基于gossip协议，它是最终一致的。这意味着，在任何时候，通过你本地Agent看到的结果可能不能准确匹配server的状态。为了查看到一致的信息，可使用HTTP API(将自动转发)到Consul Server上去进行查询：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ curl localhost:8500/v1/catalog/nodes
</span></span><span class="line"><span class="cl">[
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        &#34;ID&#34;: &#34;2e524113-7caf-643a-80bb-a2fa00c2673b&#34;,
</span></span><span class="line"><span class="cl">        &#34;Node&#34;: &#34;C02Z35N9LVCF&#34;,
</span></span><span class="line"><span class="cl">        &#34;Address&#34;: &#34;127.0.0.1&#34;,
</span></span><span class="line"><span class="cl">        &#34;Datacenter&#34;: &#34;dc1&#34;,
</span></span><span class="line"><span class="cl">        &#34;TaggedAddresses&#34;: {
</span></span><span class="line"><span class="cl">            &#34;lan&#34;: &#34;127.0.0.1&#34;,
</span></span><span class="line"><span class="cl">            &#34;wan&#34;: &#34;127.0.0.1&#34;
</span></span><span class="line"><span class="cl">        },
</span></span><span class="line"><span class="cl">        &#34;Meta&#34;: {
</span></span><span class="line"><span class="cl">            &#34;consul-network-segment&#34;: &#34;&#34;
</span></span><span class="line"><span class="cl">        },
</span></span><span class="line"><span class="cl">        &#34;CreateIndex&#34;: 9,
</span></span><span class="line"><span class="cl">        &#34;ModifyIndex&#34;: 10
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">]
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="停止agent">停止Agent</h3>
<p>你可以使用 Ctrl-C 优雅的关闭Agent，中断Agent之后你可以看到它离开了集群并关闭.
退出后，Consul提醒其他集群成员，这个节点离开了。如果你强行杀掉进程，集群的其他成员应该能检测到这个节点失效了。当一个成员离开，他的服务和检测也会从目录中移除。当一个成员失效了，他的健康状况被简单的标记为危险，但是不会从目录中移除。Consul会自动尝试对失效的节点进行重连，允许他从某些网络条件下恢复过来。</p>
<h2 id="注册服务">注册服务</h2>
<p>在之前的步骤我们运行了第一个agent，看到了集群的成员。现在我们将注册第一个服务并查询这些服务。</p>
<h3 id="定义一个服务">定义一个服务</h3>
<p>可以通过提供服务定义或者调用HTTP API来注册一个服务，服务定义文件是注册服务的最通用的方式。</p>
<p>首先，为Consul配置创建一个目录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ sudo mkdir /etc/consul.d
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，编写服务定义配置文件。假设我们有一个名叫web的服务运行在 80端口。另外，我们将给他设置一个标签，这样我们可以使用它作为额外的查询方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">echo &#39;{&#34;service&#34;: {&#34;name&#34;: &#34;web&#34;, &#34;tags&#34;: [&#34;rails&#34;], &#34;port&#34;: 80}}&#39; &gt; /etc/consul.d/web.json
</span></span></code></pre></td></tr></table>
</div>
</div><p>重新启动Agent，设置配置目录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ sudo consul agent -dev -config-dir /etc/consul.d/web.json
</span></span><span class="line"><span class="cl">==&gt; Starting Consul agent...
</span></span><span class="line"><span class="cl">           Version: &#39;v1.6.1&#39;
</span></span><span class="line"><span class="cl">           Node ID: &#39;feba8d74-4a3a-9b42-305f-eea7da207c9c&#39;
</span></span><span class="line"><span class="cl">         Node name: &#39;C02Z35N9LVCF&#39;
</span></span><span class="line"><span class="cl">        Datacenter: &#39;dc1&#39; (Segment: &#39;&lt;all&gt;&#39;)
</span></span><span class="line"><span class="cl">            Server: true (Bootstrap: false)
</span></span><span class="line"><span class="cl">       Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, gRPC: 8502, DNS: 8600)
</span></span><span class="line"><span class="cl">      Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302)
</span></span><span class="line"><span class="cl">           Encrypt: Gossip: false, TLS-Outgoing: false, TLS-Incoming: false, Auto-Encrypt-TLS: false
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">==&gt; Log data will now stream in as it occurs:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:29 [DEBUG] agent: Using random ID &#34;feba8d74-4a3a-9b42-305f-eea7da207c9c&#34; as node ID
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:29 [DEBUG] tlsutil: Update with version 1
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:29 [DEBUG] tlsutil: OutgoingRPCWrapper with version 1
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:29 [INFO]  raft: Initial configuration (index=1): [{Suffrage:Voter ID:feba8d74-4a3a-9b42-305f-eea7da207c9c Address:127.0.0.1:8300}]
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:29 [INFO]  raft: Node at 127.0.0.1:8300 [Follower] entering Follower state (Leader: &#34;&#34;)
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:29 [INFO] serf: EventMemberJoin: C02Z35N9LVCF.dc1 127.0.0.1
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:29 [INFO] serf: EventMemberJoin: C02Z35N9LVCF 127.0.0.1
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:29 [INFO] consul: Adding LAN server C02Z35N9LVCF (Addr: tcp/127.0.0.1:8300) (DC: dc1)
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:29 [INFO] consul: Handled member-join event for server &#34;C02Z35N9LVCF.dc1&#34; in area &#34;wan&#34;
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:29 [INFO] agent: Started DNS server 127.0.0.1:8600 (tcp)
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:29 [INFO] agent: Started DNS server 127.0.0.1:8600 (udp)
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:29 [INFO] agent: Started HTTP server on 127.0.0.1:8500 (tcp)
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:29 [INFO] agent: Started gRPC server on 127.0.0.1:8502 (tcp)
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:29 [INFO] agent: started state syncer
</span></span><span class="line"><span class="cl">==&gt; Consul agent running!
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:30 [WARN]  raft: Heartbeat timeout from &#34;&#34; reached, starting election
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:30 [INFO]  raft: Node at 127.0.0.1:8300 [Candidate] entering Candidate state in term 2
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:30 [DEBUG] raft: Votes needed: 1
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:30 [DEBUG] raft: Vote granted from feba8d74-4a3a-9b42-305f-eea7da207c9c in term 2. Tally: 1
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:30 [INFO]  raft: Election won. Tally: 1
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:30 [INFO]  raft: Node at 127.0.0.1:8300 [Leader] entering Leader state
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:30 [INFO] consul: cluster leadership acquired
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:30 [INFO] consul: New leader elected: C02Z35N9LVCF
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:30 [INFO] connect: initialized primary datacenter CA with provider &#34;consul&#34;
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:30 [DEBUG] consul: Skipping self join check for &#34;C02Z35N9LVCF&#34; since the cluster is too small
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:30 [INFO] consul: member &#39;C02Z35N9LVCF&#39; joined, marking health alive
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:30 [DEBUG] agent: Skipping remote check &#34;serfHealth&#34; since it is managed automatically
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:30 [INFO] agent: Synced service &#34;web&#34;
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:30 [DEBUG] agent: Node info in sync
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:32 [DEBUG] tlsutil: OutgoingRPCWrapper with version 1
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:32 [DEBUG] agent: Skipping remote check &#34;serfHealth&#34; since it is managed automatically
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:32 [DEBUG] agent: Service &#34;web&#34; in sync
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:32 [DEBUG] agent: Node info in sync
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:32 [DEBUG] agent: Service &#34;web&#34; in sync
</span></span><span class="line"><span class="cl">    2019/11/20 22:17:32 [DEBUG] agent: Node info in sync
</span></span></code></pre></td></tr></table>
</div>
</div><p>日志中的<code>Synced service 'web'</code>表示Agent从配置文件中载入了服务定义，并且成功注册到服务目录。</p>
<p>如果想注册多个服务，就可以在Consul配置目录创建多个服务定义文件。</p>
<h3 id="查询服务">查询服务</h3>
<p>一旦Agent启动并且服务同步了，我们可就以通过DNS或者HTTP API来查询服务。</p>
<h4 id="dns-api">DNS API</h4>
<p>我们首先使用DNS API来查询。在DNS API中，服务的DNS名字是 <code>NAME.service.consul</code>。虽然是可配置的，但默认的所有DNS名字会都在consul命名空间下，这个子域告诉Consul，我们在查询服务，<code>NAME</code>则是服务的名称.</p>
<p>对于我们上面注册的Web服务.它的域名是 <code>web.service.consul</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ dig @127.0.0.1 -p 8600 web.service.consul
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; @127.0.0.1 -p 8600 web.service.consul
</span></span><span class="line"><span class="cl">; (1 server found)
</span></span><span class="line"><span class="cl">;; global options: +cmd
</span></span><span class="line"><span class="cl">;; Got answer:
</span></span><span class="line"><span class="cl">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 27222
</span></span><span class="line"><span class="cl">;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 2
</span></span><span class="line"><span class="cl">;; WARNING: recursion requested but not available
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">;; OPT PSEUDOSECTION:
</span></span><span class="line"><span class="cl">; EDNS: version: 0, flags:; udp: 4096
</span></span><span class="line"><span class="cl">;; QUESTION SECTION:
</span></span><span class="line"><span class="cl">;web.service.consul.                IN        A
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">;; ANSWER SECTION:
</span></span><span class="line"><span class="cl">web.service.consul.        0        IN        A        127.0.0.1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">;; ADDITIONAL SECTION:
</span></span><span class="line"><span class="cl">web.service.consul.        0        IN        TXT        &#34;consul-network-segment=&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">;; Query time: 8 msec
</span></span><span class="line"><span class="cl">;; SERVER: 127.0.0.1#8600(127.0.0.1)
</span></span><span class="line"><span class="cl">;; WHEN: Wed Nov 20 22:26:14 CST 2019
</span></span><span class="line"><span class="cl">;; MSG SIZE  rcvd: 99
</span></span></code></pre></td></tr></table>
</div>
</div><p>如你所见,一个A记录返回了一个可用的服务所在的节点的IP地址。A记录只能设置为IP地址，有也可用使用 DNS API 来接收包含地址和端口的 <code>SRV</code> 记录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ dig @127.0.0.1 -p 8600 web.service.consul SRV
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; @127.0.0.1 -p 8600 web.service.consul SRV
</span></span><span class="line"><span class="cl">; (1 server found)
</span></span><span class="line"><span class="cl">;; global options: +cmd
</span></span><span class="line"><span class="cl">;; Got answer:
</span></span><span class="line"><span class="cl">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 49043
</span></span><span class="line"><span class="cl">;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 3
</span></span><span class="line"><span class="cl">;; WARNING: recursion requested but not available
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">;; OPT PSEUDOSECTION:
</span></span><span class="line"><span class="cl">; EDNS: version: 0, flags:; udp: 4096
</span></span><span class="line"><span class="cl">;; QUESTION SECTION:
</span></span><span class="line"><span class="cl">;web.service.consul.                IN        SRV
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">;; ANSWER SECTION:
</span></span><span class="line"><span class="cl">web.service.consul.        0        IN        SRV        1 1 80 C02Z35N9LVCF.node.dc1.consul.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">;; ADDITIONAL SECTION:
</span></span><span class="line"><span class="cl">C02Z35N9LVCF.node.dc1.consul. 0        IN        A        127.0.0.1
</span></span><span class="line"><span class="cl">C02Z35N9LVCF.node.dc1.consul. 0        IN        TXT        &#34;consul-network-segment=&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">;; Query time: 1 msec
</span></span><span class="line"><span class="cl">;; SERVER: 127.0.0.1#8600(127.0.0.1)
</span></span><span class="line"><span class="cl">;; WHEN: Wed Nov 20 22:28:14 CST 2019
</span></span><span class="line"><span class="cl">;; MSG SIZE  rcvd: 147
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>SRV</code>记录告诉我们 web 这个服务运行于节点<code>C02Z35N9LVCF.node.dc1.consul</code> 的80端口，DNS额外返回了节点的A记录。</p>
<p>最后，我们也可以用 DNS API 通过标签来过滤服务，基于标签的服务查询格式为<code>TAG.NAME.service.consul</code>。在下面的例子中，我们请求Consul返回有 rails标签的 web服务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ dig @127.0.0.1 -p 8600 rails.web.service.consul SRV
</span></span><span class="line"><span class="cl"># 输出信息略
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="http-api">HTTP API</h4>
<p>除了DNS API之外，也可以使用HTTP API查询所有服务实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ curl http://localhost:8500/v1/catalog/service/web
</span></span><span class="line"><span class="cl">[
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        &#34;ID&#34;: &#34;feba8d74-4a3a-9b42-305f-eea7da207c9c&#34;,
</span></span><span class="line"><span class="cl">        &#34;Node&#34;: &#34;C02Z35N9LVCF&#34;,
</span></span><span class="line"><span class="cl">        &#34;Address&#34;: &#34;127.0.0.1&#34;,
</span></span><span class="line"><span class="cl">        &#34;Datacenter&#34;: &#34;dc1&#34;,
</span></span><span class="line"><span class="cl">        &#34;TaggedAddresses&#34;: {
</span></span><span class="line"><span class="cl">            &#34;lan&#34;: &#34;127.0.0.1&#34;,
</span></span><span class="line"><span class="cl">            &#34;wan&#34;: &#34;127.0.0.1&#34;
</span></span><span class="line"><span class="cl">        },
</span></span><span class="line"><span class="cl">        &#34;NodeMeta&#34;: {
</span></span><span class="line"><span class="cl">            &#34;consul-network-segment&#34;: &#34;&#34;
</span></span><span class="line"><span class="cl">        },
</span></span><span class="line"><span class="cl">        &#34;ServiceKind&#34;: &#34;&#34;,
</span></span><span class="line"><span class="cl">        &#34;ServiceID&#34;: &#34;web&#34;,
</span></span><span class="line"><span class="cl">        &#34;ServiceName&#34;: &#34;web&#34;,
</span></span><span class="line"><span class="cl">        &#34;ServiceTags&#34;: [
</span></span><span class="line"><span class="cl">            &#34;rails&#34;
</span></span><span class="line"><span class="cl">        ],
</span></span><span class="line"><span class="cl">        &#34;ServiceAddress&#34;: &#34;&#34;,
</span></span><span class="line"><span class="cl">        &#34;ServiceWeights&#34;: {
</span></span><span class="line"><span class="cl">            &#34;Passing&#34;: 1,
</span></span><span class="line"><span class="cl">            &#34;Warning&#34;: 1
</span></span><span class="line"><span class="cl">        },
</span></span><span class="line"><span class="cl">        &#34;ServiceMeta&#34;: {},
</span></span><span class="line"><span class="cl">        &#34;ServicePort&#34;: 80,
</span></span><span class="line"><span class="cl">        &#34;ServiceEnableTagOverride&#34;: false,
</span></span><span class="line"><span class="cl">        &#34;ServiceProxy&#34;: {
</span></span><span class="line"><span class="cl">            &#34;MeshGateway&#34;: {}
</span></span><span class="line"><span class="cl">        },
</span></span><span class="line"><span class="cl">        &#34;ServiceConnect&#34;: {},
</span></span><span class="line"><span class="cl">        &#34;CreateIndex&#34;: 10,
</span></span><span class="line"><span class="cl">        &#34;ModifyIndex&#34;: 10
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">]
</span></span></code></pre></td></tr></table>
</div>
</div><p>只查看健康服务实例的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ curl http://localhost:8500/v1/catalog/service/web?passing
</span></span><span class="line"><span class="cl"># 输出信息略
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="更新服务">更新服务</h3>
<p>服务定义可以通过修改配置文件并发送<code>SIGHUP</code>给Agent来进行更新，这样可以在不关闭服务或者保持服务请求可用的情况下进行更新。</p>
<p>参考来源：</p>
<ol>
<li><a href="https://github.com/hashicorp/consul"target="_blank" rel="external nofollow noopener noreferrer">https://github.com/hashicorp/consul<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://www.consul.io/intro/getting-started.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.consul.io/intro/getting-started.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://book-consul-guide.vnzmi.com/01_what_is_consul.html"target="_blank" rel="external nofollow noopener noreferrer">https://book-consul-guide.vnzmi.com/01_what_is_consul.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ol>
]]></description></item><item><title>JSON Web Token入门手册</title><link>https://xzygis.github.io/posts/usage-of-json-web-token/</link><pubDate>Thu, 30 Jan 2020 13:10:39 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/usage-of-json-web-token/</guid><description><![CDATA[<h2 id="跨域认证问题">跨域认证问题</h2>
<p>互联网服务离不开用户认证。一般流程是下面这样：</p>
<ol>
<li>用户向服务器发送用户名和密码。</li>
<li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li>
<li>服务器向用户返回一个 session_id，写入用户的 Cookie。</li>
<li>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li>
<li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li>
</ol>
<p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p>
<p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p>
<ul>
<li>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</li>
<li>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</li>
</ul>
<h2 id="什么是jwt">什么是JWT？</h2>
<p>Json web token (JWT)，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519)。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token可直接被用于认证，也可被加密。</p>
<h2 id="jwt-的原理">JWT 的原理</h2>
<p>服务器认证以后，生成一个经过签名的 JSON 对象，发回给用户，服务器则不用保存任何 session 数据了。从而把服务器变成无状态的，易于实现扩展。</p>
<h2 id="jwt-的使用场景">JWT 的使用场景</h2>
<p>以下是两个JWT的应用场景：</p>
<ol>
<li>鉴权：这是JWT最常见的应用场景。当用户登录成功后，随后的每个请求都将带上JWT，从而允许用户访问被授权的服务和资源。由于它开销小切易于使用，当前被广泛应用于单点登录（Single Sign On）。</li>
<li>信息交换：JWT是不同组织间交换信息的一种很好的方式。因为JWT可以被签名（例如，通过公钥/私钥对），你可以确信信息发送者就是它们说声明的身份。此外，签名是用Header和Payload计算出来的，你可以验证内容是否被篡改。</li>
</ol>
<h2 id="jwt-的数据结构">JWT 的数据结构</h2>
<p>扁平化形式的JWT是由通过 <code>.</code> 分隔的三部分组成，他们分别是：</p>
<ul>
<li><code>Header</code></li>
<li><code>Payload</code></li>
<li><code>Signature</code></li>
</ul>
<p>所以，一个JWT看起来通常是如下的形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">xxxxx.yyyyy.zzzzz
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="header">Header</h3>
<p>头部由两部分组成：</p>
<ul>
<li>token类型，即JWT；</li>
<li>签名算法，例如HMAC SHA256或RSA。</li>
</ul>
<p>一个Header的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;alg&#34;</span><span class="p">:</span> <span class="s2">&#34;HS256&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;typ&#34;</span><span class="p">:</span> <span class="s2">&#34;JWT&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>随后，以上JSON对象会通过 <code>Base64Url</code> 编码为JWT的第一部分。</p>
<h3 id="payload">Payload</h3>
<p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p>
<ul>
<li>标准中注册的声明</li>
<li>公共的声明</li>
<li>私有的声明</li>
</ul>
<p><strong>标准中注册的声明：</strong></p>
<ul>
<li>iss: jwt签发者</li>
<li>sub: jwt所面向的用户</li>
<li>aud: 接收jwt的一方</li>
<li>exp: jwt的过期时间，这个过期时间必须要大于签发时间</li>
<li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li>
<li>iat: jwt的签发时间</li>
<li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li>
</ul>
<p><strong>公共的声明 ：</strong>
公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。</p>
<p><strong>私有的声明 ：</strong>
私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p>
<p>一个Payload的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;sub&#34;</span><span class="p">:</span> <span class="s2">&#34;1234567890&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;John Doe&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;admin&#34;</span><span class="p">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>随后，Payload会通过 <code>Base64Url</code> 编码为JWT的第二部分。</p>
<h3 id="signature">Signature</h3>
<p>创建签名需要用到编码后的 Header、编码后的 Payload、秘钥、Header中指定的算法。</p>
<p>如果你想使用HMAC SHA256算法，签名将通过如下方式生成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">HMACSHA256</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nf">base64UrlEncode</span><span class="p">(</span><span class="nx">header</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;.&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">  <span class="nf">base64UrlEncode</span><span class="p">(</span><span class="nx">payload</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="nx">secret</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你想把以上概念付诸实践，可以通过 <a href="https://jwt.io/"target="_blank" rel="external nofollow noopener noreferrer">https://jwt.io/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 提供的工具来玩一玩 JWT 。如下图所示：
</p>
<h2 id="jwt-的使用方式">JWT 的使用方式</h2>
<p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。
此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">Authorization</span><span class="o">:</span> <span class="nx">Bearer</span> <span class="o">&lt;</span><span class="nx">token</span><span class="o">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p>
<h2 id="jwt-的几个特点">JWT 的几个特点</h2>
<ul>
<li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li>
<li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li>
<li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li>
<li>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li>
<li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li>
<li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li>
</ul>
<h2 id="示例代码">示例代码</h2>
<p>Go语言版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">util</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;crypto/rsa&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;crypto/x509&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;encoding/pem&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;errors&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/dgrijalva/jwt-go&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ErrVerifyFailed</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;verify failed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//https://godoc.org/github.com/dgrijalva/jwt-go#example-New--Hmac
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">CreateToken</span><span class="p">(</span><span class="nx">claims</span> <span class="nx">jwt</span><span class="p">.</span><span class="nx">MapClaims</span><span class="p">,</span> <span class="nx">privateKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">token</span> <span class="o">:=</span> <span class="nx">jwt</span><span class="p">.</span><span class="nf">NewWithClaims</span><span class="p">(</span><span class="nx">jwt</span><span class="p">.</span><span class="nx">SigningMethodRS512</span><span class="p">,</span> <span class="nx">claims</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">block</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">pem</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">privateKey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">block</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;private key error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">priv</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">x509</span><span class="p">.</span><span class="nf">ParsePKCS8PrivateKey</span><span class="p">(</span><span class="nx">block</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">token</span><span class="p">.</span><span class="nf">SignedString</span><span class="p">(</span><span class="nx">priv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//https://godoc.org/github.com/dgrijalva/jwt-go#example-Parse--Hmac
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">VerifyToken</span><span class="p">(</span><span class="nx">tokenString</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">publicKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">jwt</span><span class="p">.</span><span class="nx">MapClaims</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">token</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">jwt</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">tokenString</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">token</span> <span class="o">*</span><span class="nx">jwt</span><span class="p">.</span><span class="nx">Token</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">token</span><span class="p">.</span><span class="nx">Method</span><span class="p">.(</span><span class="o">*</span><span class="nx">jwt</span><span class="p">.</span><span class="nx">SigningMethodRSA</span><span class="p">);</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;unexpected signing method: %v&#34;</span><span class="p">,</span> <span class="nx">token</span><span class="p">.</span><span class="nx">Header</span><span class="p">[</span><span class="s">&#34;alg&#34;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">token</span><span class="p">.</span><span class="nx">Header</span><span class="p">[</span><span class="s">&#34;alg&#34;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#34;RS512&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;unexpected siging alg: %v&#34;</span><span class="p">,</span> <span class="nx">token</span><span class="p">.</span><span class="nx">Header</span><span class="p">[</span><span class="s">&#34;alg&#34;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">block</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">pem</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">publicKey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">block</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrVerifyFailed</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">pubInterface</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">x509</span><span class="p">.</span><span class="nf">ParsePKIXPublicKey</span><span class="p">(</span><span class="nx">block</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrVerifyFailed</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">pub</span> <span class="o">:=</span> <span class="nx">pubInterface</span><span class="p">.(</span><span class="o">*</span><span class="nx">rsa</span><span class="p">.</span><span class="nx">PublicKey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">pub</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrVerifyFailed</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">claims</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">token</span><span class="p">.</span><span class="nx">Claims</span><span class="p">.(</span><span class="nx">jwt</span><span class="p">.</span><span class="nx">MapClaims</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">token</span><span class="p">.</span><span class="nx">Valid</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">claims</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrVerifyFailed</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>参考来源：</p>
<ol>
<li><a href="https://jwt.io/introduction/"target="_blank" rel="external nofollow noopener noreferrer">https://jwt.io/introduction/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://www.jianshu.com/p/576dbf44b2ae"target="_blank" rel="external nofollow noopener noreferrer">https://www.jianshu.com/p/576dbf44b2ae<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ol>
]]></description></item><item><title>Docker之容器使用</title><link>https://xzygis.github.io/posts/usage-of-docker-container/</link><pubDate>Thu, 30 Jan 2020 13:01:19 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/usage-of-docker-container/</guid><description><![CDATA[<h2 id="获取镜像">获取镜像</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker pull ubuntu
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="启动容器">启动容器：</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker run -it ubuntu /bin/bash
</span></span><span class="line"><span class="cl"># 要退出终端，直接输入 exit
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="启动已停止运行的容器">启动已停止运行的容器</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker ps -a
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="启动已停止运行的容器-1">启动已停止运行的容器</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker start b750bbbcfd88 
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="后台运行">后台运行</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker run -itd --name ubuntu-test ubuntu /bin/bash
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="停止一个容器">停止一个容器</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker stop &lt;容器 ID&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>停止的容器可以通过 docker restart 重启：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker restart &lt;容器 ID&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="进入容器">进入容器</h2>
<p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p>
<ul>
<li><code>docker attach</code>： 如果从这个容器退出（<code>exit</code>），会导致容器的停止。</li>
<li><code>docker exec</code>：推荐大家使用 <code>docker exec</code> 命令，因为此退出容器终端，不会导致容器的停止。</li>
</ul>
<p>exec命令使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker exec -it 243c32535da7 /bin/bash
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="导出和导入容器">导出和导入容器</h2>
<h3 id="导出容器">导出容器</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker export 1e560fca3906 &gt; ubuntu.tar
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="导入容器">导入容器</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1
</span></span></code></pre></td></tr></table>
</div>
</div><p>或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker import docker/ubuntu.tar test/ubuntu:v1 
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以通过指定 URL 或者某个目录来导入，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker import http://example.com/exampleimage.tgz example/imagerepo
</span></span></code></pre></td></tr></table>
</div>
</div><p>参考来源：</p>
<p>[1] <a href="https://www.runoob.com/docker/docker-container-usage.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.runoob.com/docker/docker-container-usage.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item></channel></rss>