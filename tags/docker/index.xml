<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>docker - 标签 - TechInsights - Chuxing's Blog</title><link>https://xzygis.github.io/tags/docker/</link><description>docker - 标签 - TechInsights - Chuxing's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xzygis@163.com (chuxing)</managingEditor><webMaster>xzygis@163.com (chuxing)</webMaster><lastBuildDate>Thu, 30 Jan 2020 13:01:19 +0000</lastBuildDate><atom:link href="https://xzygis.github.io/tags/docker/" rel="self" type="application/rss+xml"/><item><title>Docker之容器使用</title><link>https://xzygis.github.io/posts/usage-of-docker-container/</link><pubDate>Thu, 30 Jan 2020 13:01:19 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/usage-of-docker-container/</guid><description><![CDATA[<h2 id="获取镜像">获取镜像</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker pull ubuntu
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="启动容器">启动容器：</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker run -it ubuntu /bin/bash
</span></span><span class="line"><span class="cl"># 要退出终端，直接输入 exit
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="启动已停止运行的容器">启动已停止运行的容器</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker ps -a
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="启动已停止运行的容器-1">启动已停止运行的容器</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker start b750bbbcfd88 
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="后台运行">后台运行</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker run -itd --name ubuntu-test ubuntu /bin/bash
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="停止一个容器">停止一个容器</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker stop &lt;容器 ID&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>停止的容器可以通过 docker restart 重启：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker restart &lt;容器 ID&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="进入容器">进入容器</h2>
<p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p>
<ul>
<li><code>docker attach</code>： 如果从这个容器退出（<code>exit</code>），会导致容器的停止。</li>
<li><code>docker exec</code>：推荐大家使用 <code>docker exec</code> 命令，因为此退出容器终端，不会导致容器的停止。</li>
</ul>
<p>exec命令使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker exec -it 243c32535da7 /bin/bash
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="导出和导入容器">导出和导入容器</h2>
<h3 id="导出容器">导出容器</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker export 1e560fca3906 &gt; ubuntu.tar
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="导入容器">导入容器</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1
</span></span></code></pre></td></tr></table>
</div>
</div><p>或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker import docker/ubuntu.tar test/ubuntu:v1 
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以通过指定 URL 或者某个目录来导入，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker import http://example.com/exampleimage.tgz example/imagerepo
</span></span></code></pre></td></tr></table>
</div>
</div><p>参考来源：</p>
<p>[1] <a href="https://www.runoob.com/docker/docker-container-usage.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.runoob.com/docker/docker-container-usage.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Docker之镜像使用</title><link>https://xzygis.github.io/posts/usage-of-docker-image/</link><pubDate>Thu, 30 Jan 2020 12:58:32 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/usage-of-docker-image/</guid><description><![CDATA[<h2 id="获取镜像">获取镜像</h2>
<p>用法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker pull [OPTIONS] NAME[:TAG|@DIGEST]
</span></span></code></pre></td></tr></table>
</div>
</div><p>例如：<code>docker pull ubuntu:18.04</code></p>
<h2 id="启动容器">启动容器</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker run -it --rm ubuntu:18.04 bash
</span></span></code></pre></td></tr></table>
</div>
</div><p>简要的说明一下上面用到的参数:</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>表示交互式操作，一个是<code>-t</code>表示终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用<code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 ubuntu:18.04 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。</li>
</ul>
<h2 id="查看镜像列表">查看镜像列表</h2>
<p>使用<code>docker image ls</code>或者<code>docker images</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker image ls
</span></span><span class="line"><span class="cl">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span class="line"><span class="cl">ubuntu              18.04               93fd78260bd1        5 weeks ago         86.2MB
</span></span><span class="line"><span class="cl">ubuntu              latest              93fd78260bd1        5 weeks ago         86.2MB
</span></span><span class="line"><span class="cl">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker images
</span></span><span class="line"><span class="cl">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span class="line"><span class="cl">ubuntu              18.04               93fd78260bd1        5 weeks ago         86.2MB
</span></span><span class="line"><span class="cl">ubuntu              latest              93fd78260bd1        5 weeks ago         86.2MB
</span></span><span class="line"><span class="cl">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB
</span></span></code></pre></td></tr></table>
</div>
</div><p>列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。</p>
<h2 id="镜像体积">镜像体积</h2>
<p>这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:18.04</code> 镜像大小，在这里是 127 MB，但是在 Docker Hub 显示的却是 50 MB。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p>
<p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker system df
</span></span><span class="line"><span class="cl">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
</span></span><span class="line"><span class="cl">Images              2                   2                   86.18MB             0B (0%)
</span></span><span class="line"><span class="cl">Containers          14                  2                   148B                25B (16%)
</span></span><span class="line"><span class="cl">Local Volumes       0                   0                   0B                  0B
</span></span><span class="line"><span class="cl">Build Cache         0                   0                   0B                  0B
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="虚悬镜像">虚悬镜像</h2>
<p>由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为<code>&lt;none&gt;</code>的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) 。</p>
<h2 id="中间层镜像">中间层镜像</h2>
<p>为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker image ls -a
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p>
<p>以特定格式显示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker image ls --format &#34;{{.ID}}: {{.Repository}}&#34;
</span></span><span class="line"><span class="cl">93fd78260bd1: ubuntu
</span></span><span class="line"><span class="cl">93fd78260bd1: ubuntu
</span></span><span class="line"><span class="cl">4ab4c602aa5e: hello-world
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker image ls --format &#34;table {{.ID}}\t{{.Repository}}\t{{.Tag}}&#34;
</span></span><span class="line"><span class="cl">IMAGE ID            REPOSITORY          TAG
</span></span><span class="line"><span class="cl">93fd78260bd1        ubuntu              18.04
</span></span><span class="line"><span class="cl">93fd78260bd1        ubuntu              latest
</span></span><span class="line"><span class="cl">4ab4c602aa5e        hello-world         latest
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="删除本地镜像">删除本地镜像</h2>
<p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p>
<h2 id="untagged-和-deleted">Untagged 和 Deleted</h2>
<p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是<code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p>
<p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 Delete 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p>
<p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。</p>
<p>除了镜像依赖以外，还需要注意的是<strong>容器对镜像的依赖</strong>。<strong>如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像</strong>。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p>
<h2 id="利用-commit-理解镜像构成">利用 commit 理解镜像构成</h2>
<p>注意： <code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制镜像应该使用 <code>Dockerfile</code> 来完成。</p>
<p>镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p>
<p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker run --name webserver -d -p 80:80 nginx
</span></span></code></pre></td></tr></table>
</div>
</div><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 webserver，并且映射了 <code>80</code> 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p>
<p>用浏览器访问的话，我们会看到默认的 <code>Nginx</code> 欢迎页面内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Welcome to nginx!
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">If you see this page, the nginx web server is successfully installed and working. Further configuration is required.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">For online documentation and support please refer to nginx.org.
</span></span><span class="line"><span class="cl"> Commercial support is available at nginx.com.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Thank you for using nginx.
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们想要修改欢迎页面的内容，可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker exec -it webserver bash
</span></span><span class="line"><span class="cl">root@3729b97e8226:/# echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html
</span></span><span class="line"><span class="cl">root@3729b97e8226:/# exit
</span></span><span class="line"><span class="cl">exit
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p>
<p>然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 /usr/share/nginx/html/index.html 的内容。现在我们再刷新浏览器的话，会发现内容被改变了。</p>
<p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker diff webserver
</span></span><span class="line"><span class="cl">C /usr
</span></span><span class="line"><span class="cl">C /usr/share
</span></span><span class="line"><span class="cl">C /usr/share/nginx
</span></span><span class="line"><span class="cl">C /usr/share/nginx/html
</span></span><span class="line"><span class="cl">C /usr/share/nginx/html/index.html
</span></span><span class="line"><span class="cl">C /root
</span></span><span class="line"><span class="cl">A /root/.bash_history
</span></span><span class="line"><span class="cl">C /var
</span></span><span class="line"><span class="cl">C /var/cache
</span></span><span class="line"><span class="cl">C /var/cache/nginx
</span></span><span class="line"><span class="cl">A /var/cache/nginx/scgi_temp
</span></span><span class="line"><span class="cl">A /var/cache/nginx/uwsgi_temp
</span></span><span class="line"><span class="cl">A /var/cache/nginx/client_temp
</span></span><span class="line"><span class="cl">A /var/cache/nginx/fastcgi_temp
</span></span><span class="line"><span class="cl">A /var/cache/nginx/proxy_temp
</span></span><span class="line"><span class="cl">C /run
</span></span><span class="line"><span class="cl">A /run/nginx.pid
</span></span></code></pre></td></tr></table>
</div>
</div><p>当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。</p>
<p>docker commit 的语法格式为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以用下面的命令将容器保存为镜像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker commit --author &#34;chuxing&#34; --message &#34;update page&#34; webserver nginx:v2
</span></span><span class="line"><span class="cl">sha256:8aaa0b63a1b842fb301d5d691cae92d9fdb52c73f37858eefada4325a36474f0
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以在 <code>docker image ls</code> 中看到这个新定制的镜像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker image ls nginx
</span></span><span class="line"><span class="cl">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE
</span></span><span class="line"><span class="cl">nginx               v2                  8aaa0b63a1b8        About a minute ago   109MB
</span></span><span class="line"><span class="cl">nginx               latest              568c4670fa80        4 weeks ago          109MB
</span></span></code></pre></td></tr></table>
</div>
</div><p>新的镜像定制好后，我们可以运行这个镜像:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run --name web2 -d -p 81:80 nginx:v2
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="慎用-docker-commit">慎用 docker commit</h2>
<p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p>
<ol>
<li>如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。</li>
<li>使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。</li>
<li>回顾之前提及的镜像所使用的分层存储的概念，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，每一次修改都会让镜像更加臃肿一次，这会让镜像更加臃肿。</li>
</ol>
<h2 id="镜像导入和导出">镜像导入和导出</h2>
<h3 id="导出镜像">导出镜像</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker save -o nginx.tar nginx:latest 
</span></span></code></pre></td></tr></table>
</div>
</div><p>或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker save &gt; nginx.tar nginx:latest 
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="导入镜像">导入镜像</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker load -i nginx.tar
</span></span></code></pre></td></tr></table>
</div>
</div><p>或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ docker load &lt; nginx.tar
</span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>CentOS安装docker</title><link>https://xzygis.github.io/posts/centos-install-docker/</link><pubDate>Thu, 30 Jan 2020 12:56:35 +0000</pubDate><author>chuxing</author><guid>https://xzygis.github.io/posts/centos-install-docker/</guid><description><![CDATA[<h3 id="1-移除旧的版本">1. 移除旧的版本</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo yum remove docker <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>                  docker-client <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>                  docker-client-latest <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>                  docker-common <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>                  docker-latest <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>                  docker-latest-logrotate <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>                  docker-logrotate <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>                  docker-selinux <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>                  docker-engine-selinux <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>                  docker-engine
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="2-安装一些必要的系统工具">2. 安装一些必要的系统工具</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo yum install -y yum-utils device-mapper-persistent-data lvm2
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="3-添加软件源信息">3. 添加软件源信息</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="4-更新-yum-缓存">4. 更新 yum 缓存</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo yum makecache fast
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="5-安装-docker-ce">5. 安装 Docker-ce</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo yum -y install docker-ce
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="6-启动-docker-后台服务">6. 启动 Docker 后台服务</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo systemctl start docker
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="7-测试运行-hello-world">7. 测试运行 hello-world</h3>
<p>初次运行可能会报如下的错误信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="o">[</span>root@VM_0_6_centos ~<span class="o">]</span><span class="c1"># docker run hello-world</span>
</span></span><span class="line"><span class="cl">Unable to find image <span class="s1">&#39;hello-world:latest&#39;</span> locally
</span></span><span class="line"><span class="cl">docker: Error response from daemon: Get https://registry-1.docker.io/v2/library/hello-world/manifests/latest: Get https://auth.docker.io/token?scope<span class="o">=</span>repository%3Alibrary%2Fhello-world%3Apull<span class="p">&amp;</span><span class="nv">service</span><span class="o">=</span>registry.docker.io: net/http: TLS handshake timeout.
</span></span><span class="line"><span class="cl">See <span class="s1">&#39;docker run --help&#39;</span>.
</span></span></code></pre></td></tr></table>
</div>
</div><p>解决方式是使用国内的镜像地址，新建<code>/etc/docker/daemon.json</code>文件，填写如下配置信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;registry-mirrors&#34;: [&#34;http://hub-mirror.c.163.com&#34;]
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>之后运行正常，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[root@VM_0_6_centos docker]# docker run hello-world
</span></span><span class="line"><span class="cl">Unable to find image &#39;hello-world:latest&#39; locally
</span></span><span class="line"><span class="cl">latest: Pulling from library/hello-world
</span></span><span class="line"><span class="cl">d1725b59e92d: Pull complete
</span></span><span class="line"><span class="cl">Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788
</span></span><span class="line"><span class="cl">Status: Downloaded newer image for hello-world:latest
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Hello from Docker!
</span></span><span class="line"><span class="cl">This message shows that your installation appears to be working correctly.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">To generate this message, Docker took the following steps:
</span></span><span class="line"><span class="cl"> 1. The Docker client contacted the Docker daemon.
</span></span><span class="line"><span class="cl"> 2. The Docker daemon pulled the &#34;hello-world&#34; image from the Docker Hub.
</span></span><span class="line"><span class="cl">    (amd64)
</span></span><span class="line"><span class="cl"> 3. The Docker daemon created a new container from that image which runs the
</span></span><span class="line"><span class="cl">    executable that produces the output you are currently reading.
</span></span><span class="line"><span class="cl"> 4. The Docker daemon streamed that output to the Docker client, which sent it
</span></span><span class="line"><span class="cl">    to your terminal.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">To try something more ambitious, you can run an Ubuntu container with:
</span></span><span class="line"><span class="cl"> $ docker run -it ubuntu bash
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Share images, automate workflows, and more with a free Docker ID:
</span></span><span class="line"><span class="cl"> https://hub.docker.com/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">For more examples and ideas, visit:
</span></span><span class="line"><span class="cl"> https://docs.docker.com/get-started/
</span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item></channel></rss>